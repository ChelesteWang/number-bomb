<!doctype html>
<html>

<head>
  <title>数字炸弹大冒险</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;">
  <link rel="preconnect" href="https://esm.sh">
  <link rel="dns-prefetch" href="https://esm.sh">
  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="icon" href="https://lf3-static.bytednsdoc.com/obj/eden-cn/uhbfnupenuhf/ai/aipa-favicon.png">
  <script src="https://sf-unpkg-src.bytedance.net/@edenx/monitor-web/dist/umd/index.js"></script>
  <script>
    var monitor = new window.index.EdenxMonitorWeb({
      slug: 'aipa-deployment',
    });
    monitor.report({
      d1: '67790d5205a7fa0039958c13',
      d2: '数字炸弹大冒险',
      d3: 'wangxinyuan.1008@bytedance.com',
    });
  </script>
</head>
<script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.3.1",
        "react-dom": "https://esm.sh/react-dom@18.3.1",
        "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
        "react-router-dom": "https://esm.sh/react-router-dom@6.28.0?bundle&external=react,react-dom",
        "react/jsx-runtime": "https://esm.sh/react@18.3.1/jsx-runtime?bundle",
        "react-is": "https://esm.sh/react-is@18.3.1?bundle",
        "@flow-web/md-box": "https://bytepack.bytedance.net/@flow-web/md-box@1.6.2?bundle&noVersion=true",
        "@ai-app/agent": "https://bytepack.bytedance.net/@ai-app/agent@0.6.0?bundle&noVersion=true",
        "@ai-app/chat-ui": "https://tosv.byted.org/obj/aipa-tos/chat-ui-v0.3.0.js",
        "matter-js": "https://esm.sh/matter-js@0.19.0?bundle&external=react,react-dom"
      }
    }
  </script>

<body>
  <div id="root"></div>
  <script type="module">
    (async function () {
      const depModules = {};
      const COMPONENT_LIBRARY_STYLE = { "antd": "https://sf-unpkg-src.bytedance.net/antd@4.18.2/dist/antd.min.css", "@douyinfe/semi-ui": "https://sf-unpkg-src.bytedance.net/@douyinfe/semi-ui@2.59.1/dist/css/semi.min.css", "@arco-design/web-react": "https://sf-unpkg-src.bytedance.net/@arco-design/web-react@2.62.1/dist/css/arco.min.css", "bootstrap": "https://sf-unpkg-src.bytedance.net/bootstrap@5.3.3/dist/css/bootstrap.min.css", "@ditto-js/smart-ui-component": "https://sf-unpkg-src.bytedance.net/@douyinfe/semi-ui@2.59.1/dist/css/semi.min.css", "@ai-app/chat-ui": "https://tosv.byted.org/obj/aipa-tos/mdbox-v1.6.2.css", "@flow-web/md-box": "https://tosv.byted.org/obj/aipa-tos/mdbox-v1.6.2.css", "@nextui-org/react": "https://tosv.byted.org/obj/aipa-tos/next-ui-css-bundle-v2.4.8.css" };
      async function loadReact() {
        // First, we should load the necessary react depInfo
        if (!depModules["react"]) {
          try {
            const [React, ReactDOM, jsxRuntime] = await Promise.all([
              import("react"),
              import("react-dom/client"),
              import("react/jsx-runtime"),
            ]);

            // 将加载的模块保存到 depModules 中
            window.React = React;
            window.ReactDOM = ReactDOM;
            depModules["react"] = {
              default: React,
              ...React,
            };
            depModules["react-dom"] = {
              default: ReactDOM,
              ...ReactDOM,
            };
            depModules["react/jsx-runtime"] = {
              default: jsxRuntime,
              ...jsxRuntime,
            };
          } catch (error) {
            console.error(error);
          }
        }
      }

      function loadCSS(url) {
        return new Promise((resolve, reject) => {
          const link = document.createElement('link');
          link.href = url;
          link.rel = 'stylesheet';
          link.type = 'text/css';
          link.onload = () => resolve(null);
          link.onerror = e => {
            console.error(e);
            reject(new Error(`Could not load CSS at ${url}`));
          };
          document.head.appendChild(link);
        });
      }

      async function loadDep(depName) {
        if (!depModules[depName]) {
          try {
            const module = await import(depName);
            depModules[depName] = module;
            if (!module.default) {
              depModules[depName] = {
                default: module,
                ...module,
              };
            }
          } catch (error) {
            console.error(error);
          }
        }
      }

      async function loadInternalModules() {
        await Promise.all(
          [

          ]
        )
      }

      // 并发加载依赖
      await Promise.all([
        loadReact(),
        loadInternalModules(),
      ]);

      var __create = Object.create;
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __getProtoOf = Object.getPrototypeOf;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __esm = (fn, res) => function __init() {
        return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
      };
      var __commonJS = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __copyProps = (to2, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to2, key) && key !== except)
              __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        }
        return to2;
      };
      var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));

      // <define:import.meta>
      var init_define_import_meta = __esm({
        "<define:import.meta>"() {
        }
      });

      // external-global-plugin:react
      var require_react = __commonJS({
        "external-global-plugin:react"(exports, module) {
          init_define_import_meta();
          module.exports = window.React;
        }
      });

      // external-global-plugin:react-dom/client
      var require_client = __commonJS({
        "external-global-plugin:react-dom/client"(exports, module) {
          init_define_import_meta();
          module.exports = window.ReactDOM;
        }
      });

      // aipa-entry.tsx
      init_define_import_meta();
      var import_react49 = __toESM(require_react());
      var import_client = __toESM(require_client());

      // App
      init_define_import_meta();
      var import_react48 = __toESM(require_react());

      // index
      init_define_import_meta();
      var import_react47 = __toESM(require_react());

      // http-url:https://esm.sh/framer-motion@^10.16.4?bundle&external=react,react-dom
      init_define_import_meta();

      // http-url:https://esm.sh/v135/framer-motion@10.18.0/X-ZS9yZWFjdCxyZWFjdC1kb20/es2022/framer-motion.bundle.mjs
      init_define_import_meta();
      var rn = __toESM(require_react(), 1);
      var import_react = __toESM(require_react(), 1);
      var import_react2 = __toESM(require_react(), 1);
      var import_react3 = __toESM(require_react(), 1);
      var import_react4 = __toESM(require_react(), 1);
      var import_react5 = __toESM(require_react(), 1);
      var import_react6 = __toESM(require_react(), 1);
      var import_react7 = __toESM(require_react(), 1);
      var import_react8 = __toESM(require_react(), 1);
      var import_react9 = __toESM(require_react(), 1);
      var import_react10 = __toESM(require_react(), 1);
      var import_react11 = __toESM(require_react(), 1);
      var import_react12 = __toESM(require_react(), 1);
      var import_react13 = __toESM(require_react(), 1);
      var import_react14 = __toESM(require_react(), 1);
      var import_react15 = __toESM(require_react(), 1);
      var import_react16 = __toESM(require_react(), 1);
      var import_react17 = __toESM(require_react(), 1);
      var import_react18 = __toESM(require_react(), 1);
      var Rt = __toESM(require_react(), 1);
      var import_react19 = __toESM(require_react(), 1);
      var import_react20 = __toESM(require_react(), 1);
      var import_react21 = __toESM(require_react(), 1);
      var Eo = __toESM(require_react(), 1);
      var import_react22 = __toESM(require_react(), 1);
      var We = __toESM(require_react(), 1);
      var import_react23 = __toESM(require_react(), 1);
      var import_react24 = __toESM(require_react(), 1);
      var sc = __toESM(require_react(), 1);
      var import_react25 = __toESM(require_react(), 1);
      var ac = __toESM(require_react(), 1);
      var import_react26 = __toESM(require_react(), 1);
      var lc = __toESM(require_react(), 1);
      var import_react27 = __toESM(require_react(), 1);
      var import_react28 = __toESM(require_react(), 1);
      var ui = __toESM(require_react(), 1);
      var import_react29 = __toESM(require_react(), 1);
      var import_react30 = __toESM(require_react(), 1);
      var gc = __toESM(require_react(), 1);
      var import_react31 = __toESM(require_react(), 1);
      var import_react32 = __toESM(require_react(), 1);
      var import_react33 = __toESM(require_react(), 1);
      var import_react34 = __toESM(require_react(), 1);
      var import_react35 = __toESM(require_react(), 1);
      var import_react36 = __toESM(require_react(), 1);
      var import_react37 = __toESM(require_react(), 1);
      var import_react38 = __toESM(require_react(), 1);
      var import_react39 = __toESM(require_react(), 1);
      var import_react40 = __toESM(require_react(), 1);
      var import_react41 = __toESM(require_react(), 1);
      var import_react42 = __toESM(require_react(), 1);
      var Wc = __toESM(require_react(), 1);
      var import_react43 = __toESM(require_react(), 1);
      var import_react44 = __toESM(require_react(), 1);
      var tn = __toESM(require_react(), 1);
      var Di = (t2, e) => () => (e || t2((e = { exports: {} }).exports, e), e.exports);
      var _i = Di((mn) => {
        "use strict";
        Object.defineProperty(mn, "__esModule", { value: true });
        function yl(t2) {
          var e = {};
          return function (o2) {
            return e[o2] === void 0 && (e[o2] = t2(o2)), e[o2];
          };
        }
        mn.default = yl;
      });
      var Yi = Di((fn) => {
        "use strict";
        Object.defineProperty(fn, "__esModule", { value: true });
        function xl(t2) {
          return t2 && typeof t2 == "object" && "default" in t2 ? t2.default : t2;
        }
        var vl = xl(_i()), Sl = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Vl = vl(function (t2) {
          return Sl.test(t2) || t2.charCodeAt(0) === 111 && t2.charCodeAt(1) === 110 && t2.charCodeAt(2) < 91;
        });
        fn.default = Vl;
      });
      var K = (0, import_react2.createContext)({ transformPagePoint: (t2) => t2, isStatic: false, reducedMotion: "never" });
      var lt = (0, import_react3.createContext)({});
      var ft = (0, import_react5.createContext)(null);
      var St = typeof document < "u";
      var X = St ? import_react6.useLayoutEffect : import_react6.useEffect;
      var ue = (0, import_react7.createContext)({ strict: false });
      var Vt = (t2) => t2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      var on = "framerAppearId";
      var Ze = "data-" + Vt(on);
      function ki(t2, e, o2, r) {
        let { visualElement: n2 } = (0, import_react4.useContext)(lt), s2 = (0, import_react4.useContext)(ue), i2 = (0, import_react4.useContext)(ft), a = (0, import_react4.useContext)(K).reducedMotion, c = (0, import_react4.useRef)();
        r = r || s2.renderer, !c.current && r && (c.current = r(t2, { visualState: e, parent: n2, props: o2, presenceContext: i2, blockInitialAnimation: i2 ? i2.initial === false : false, reducedMotionConfig: a }));
        let l2 = c.current;
        (0, import_react4.useInsertionEffect)(() => {
          l2 && l2.update(o2, i2);
        });
        let u2 = (0, import_react4.useRef)(!!(o2[Ze] && !window.HandoffComplete));
        return X(() => {
          l2 && (l2.render(), u2.current && l2.animationState && l2.animationState.animateChanges());
        }), (0, import_react4.useEffect)(() => {
          l2 && (l2.updateFeatures(), !u2.current && l2.animationState && l2.animationState.animateChanges(), u2.current && (u2.current = false, window.HandoffComplete = true));
        }), l2;
      }
      function Tt(t2) {
        return t2 && typeof t2 == "object" && Object.prototype.hasOwnProperty.call(t2, "current");
      }
      function Ii(t2, e, o2) {
        return (0, import_react8.useCallback)((r) => {
          r && t2.mount && t2.mount(r), e && (r ? e.mount(r) : e.unmount()), o2 && (typeof o2 == "function" ? o2(r) : Tt(o2) && (o2.current = r));
        }, [e]);
      }
      function bt(t2) {
        return typeof t2 == "string" || Array.isArray(t2);
      }
      function It(t2) {
        return t2 !== null && typeof t2 == "object" && typeof t2.start == "function";
      }
      var Uo = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"];
      var Je = ["initial", ...Uo];
      function $t(t2) {
        return It(t2.animate) || Je.some((e) => bt(t2[e]));
      }
      function zo(t2) {
        return !!($t(t2) || t2.variants);
      }
      function Oi(t2, e) {
        if ($t(t2)) {
          let { initial: o2, animate: r } = t2;
          return { initial: o2 === false || bt(o2) ? o2 : void 0, animate: bt(r) ? r : void 0 };
        }
        return t2.inherit !== false ? e : {};
      }
      function Bi(t2) {
        let { initial: e, animate: o2 } = Oi(t2, (0, import_react9.useContext)(lt));
        return (0, import_react9.useMemo)(() => ({ initial: e, animate: o2 }), [Fi(e), Fi(o2)]);
      }
      function Fi(t2) {
        return Array.isArray(t2) ? t2.join(" ") : t2;
      }
      var ji = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] };
      var Kt = {};
      for (let t2 in ji)
        Kt[t2] = { isEnabled: (e) => ji[t2].some((o2) => !!e[o2]) };
      function Qe(t2) {
        for (let e in t2)
          Kt[e] = { ...Kt[e], ...t2[e] };
      }
      var pt = (0, import_react10.createContext)({});
      var to = (0, import_react11.createContext)({});
      var me = Symbol.for("motionComponentSymbol");
      function eo({ preloadedFeatures: t2, createVisualElement: e, useRender: o2, useVisualState: r, Component: n2 }) {
        t2 && Qe(t2);
        function s2(a, c) {
          let l2, u2 = { ...(0, import_react.useContext)(K), ...a, layoutId: ul(a) }, { isStatic: m2 } = u2, f = Bi(a), p2 = r(a, m2);
          if (!m2 && St) {
            f.visualElement = ki(n2, p2, u2, e);
            let d = (0, import_react.useContext)(to), h = (0, import_react.useContext)(ue).strict;
            f.visualElement && (l2 = f.visualElement.loadFeatures(u2, h, t2, d));
          }
          return rn.createElement(lt.Provider, { value: f }, l2 && f.visualElement ? rn.createElement(l2, { visualElement: f.visualElement, ...u2 }) : null, o2(n2, a, Ii(p2, f.visualElement, c), p2, m2, f.visualElement));
        }
        let i2 = (0, import_react.forwardRef)(s2);
        return i2[me] = n2, i2;
      }
      function ul({ layoutId: t2 }) {
        let e = (0, import_react.useContext)(pt).id;
        return e && t2 !== void 0 ? e + "-" + t2 : t2;
      }
      function Ho(t2) {
        function e(r, n2 = {}) {
          return eo(t2(r, n2));
        }
        if (typeof Proxy > "u")
          return e;
        let o2 = /* @__PURE__ */ new Map();
        return new Proxy(e, { get: (r, n2) => (o2.has(n2) || o2.set(n2, e(n2)), o2.get(n2)) });
      }
      var Ni = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
      function fe(t2) {
        return typeof t2 != "string" || t2.includes("-") ? false : !!(Ni.indexOf(t2) > -1 || /[A-Z]/.test(t2));
      }
      var pe = {};
      function nn(t2) {
        Object.assign(pe, t2);
      }
      var Ot = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"];
      var z = new Set(Ot);
      function Wo(t2, { layout: e, layoutId: o2 }) {
        return z.has(t2) || t2.startsWith("origin") || (e || o2 !== void 0) && (!!pe[t2] || t2 === "opacity");
      }
      var A = (t2) => !!(t2 && t2.getVelocity);
      var ml = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" };
      var fl = Ot.length;
      function sn(t2, { enableHardwareAcceleration: e = true, allowTransformNone: o2 = true }, r, n2) {
        let s2 = "";
        for (let i2 = 0; i2 < fl; i2++) {
          let a = Ot[i2];
          if (t2[a] !== void 0) {
            let c = ml[a] || a;
            s2 += `${c}(${t2[a]}) `;
          }
        }
        return e && !t2.z && (s2 += "translateZ(0)"), s2 = s2.trim(), n2 ? s2 = n2(t2, r ? "" : s2) : o2 && r && (s2 = "none"), s2;
      }
      var Ui = (t2) => (e) => typeof e == "string" && e.startsWith(t2);
      var de = Ui("--");
      var $o = Ui("var(--");
      var zi = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g;
      var Gi = (t2, e) => e && typeof t2 == "number" ? e.transform(t2) : t2;
      var _ = (t2, e, o2) => Math.min(Math.max(o2, t2), e);
      var at = { test: (t2) => typeof t2 == "number", parse: parseFloat, transform: (t2) => t2 };
      var Ft = { ...at, transform: (t2) => _(0, 1, t2) };
      var oo = { ...at, default: 1 };
      var Bt = (t2) => Math.round(t2 * 1e5) / 1e5;
      var _t = /(-)?([\d]*\.?[\d])+/g;
      var an = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
      var Hi = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
      function Pt(t2) {
        return typeof t2 == "string";
      }
      var ro = (t2) => ({ test: (e) => Pt(e) && e.endsWith(t2) && e.split(" ").length === 1, parse: parseFloat, transform: (e) => `${e}${t2}` });
      var dt = ro("deg");
      var Z = ro("%");
      var T = ro("px");
      var Wi = ro("vh");
      var $i = ro("vw");
      var cn = { ...Z, parse: (t2) => Z.parse(t2) / 100, transform: (t2) => Z.transform(t2 * 100) };
      var ln = { ...at, transform: Math.round };
      var Ko = { borderWidth: T, borderTopWidth: T, borderRightWidth: T, borderBottomWidth: T, borderLeftWidth: T, borderRadius: T, radius: T, borderTopLeftRadius: T, borderTopRightRadius: T, borderBottomRightRadius: T, borderBottomLeftRadius: T, width: T, maxWidth: T, height: T, maxHeight: T, size: T, top: T, right: T, bottom: T, left: T, padding: T, paddingTop: T, paddingRight: T, paddingBottom: T, paddingLeft: T, margin: T, marginTop: T, marginRight: T, marginBottom: T, marginLeft: T, rotate: dt, rotateX: dt, rotateY: dt, rotateZ: dt, scale: oo, scaleX: oo, scaleY: oo, scaleZ: oo, skew: dt, skewX: dt, skewY: dt, distance: T, translateX: T, translateY: T, translateZ: T, x: T, y: T, z: T, perspective: T, transformPerspective: T, opacity: Ft, originX: cn, originY: cn, originZ: T, zIndex: ln, fillOpacity: Ft, strokeOpacity: Ft, numOctaves: ln };
      function he(t2, e, o2, r) {
        let { style: n2, vars: s2, transform: i2, transformOrigin: a } = t2, c = false, l2 = false, u2 = true;
        for (let m2 in e) {
          let f = e[m2];
          if (de(m2)) {
            s2[m2] = f;
            continue;
          }
          let p2 = Ko[m2], d = Gi(f, p2);
          if (z.has(m2)) {
            if (c = true, i2[m2] = d, !u2)
              continue;
            f !== (p2.default || 0) && (u2 = false);
          } else
            m2.startsWith("origin") ? (l2 = true, a[m2] = d) : n2[m2] = d;
        }
        if (e.transform || (c || r ? n2.transform = sn(t2.transform, o2, u2, r) : n2.transform && (n2.transform = "none")), l2) {
          let { originX: m2 = "50%", originY: f = "50%", originZ: p2 = 0 } = a;
          n2.transformOrigin = `${m2} ${f} ${p2}`;
        }
      }
      var ge = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
      function un(t2, e, o2) {
        for (let r in e)
          !A(e[r]) && !Wo(r, o2) && (t2[r] = e[r]);
      }
      function dl({ transformTemplate: t2 }, e, o2) {
        return (0, import_react13.useMemo)(() => {
          let r = ge();
          return he(r, e, { enableHardwareAcceleration: !o2 }, t2), Object.assign({}, r.vars, r.style);
        }, [e]);
      }
      function hl(t2, e, o2) {
        let r = t2.style || {}, n2 = {};
        return un(n2, r, t2), Object.assign(n2, dl(t2, e, o2)), t2.transformValues ? t2.transformValues(n2) : n2;
      }
      function Ki(t2, e, o2) {
        let r = {}, n2 = hl(t2, e, o2);
        return t2.drag && t2.dragListener !== false && (r.draggable = false, n2.userSelect = n2.WebkitUserSelect = n2.WebkitTouchCallout = "none", n2.touchAction = t2.drag === true ? "none" : `pan-${t2.drag === "x" ? "y" : "x"}`), t2.tabIndex === void 0 && (t2.onTap || t2.onTapStart || t2.whileTap) && (r.tabIndex = 0), r.style = n2, r;
      }
      var gl = /* @__PURE__ */ new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
      function ye(t2) {
        return t2.startsWith("while") || t2.startsWith("drag") && t2 !== "draggable" || t2.startsWith("layout") || t2.startsWith("onTap") || t2.startsWith("onPan") || t2.startsWith("onLayout") || gl.has(t2);
      }
      var qi = (t2) => !ye(t2);
      function pn(t2) {
        t2 && (qi = (e) => e.startsWith("on") ? !ye(e) : t2(e));
      }
      try {
        pn(Yi().default);
      } catch {
      }
      function dn(t2, e, o2) {
        let r = {};
        for (let n2 in t2)
          n2 === "values" && typeof t2.values == "object" || (qi(n2) || o2 === true && ye(n2) || !e && !ye(n2) || t2.draggable && n2.startsWith("onDrag")) && (r[n2] = t2[n2]);
        return r;
      }
      function Xi(t2, e, o2) {
        return typeof t2 == "string" ? t2 : T.transform(e + o2 * t2);
      }
      function Zi(t2, e, o2) {
        let r = Xi(e, t2.x, t2.width), n2 = Xi(o2, t2.y, t2.height);
        return `${r} ${n2}`;
      }
      var Tl = { offset: "stroke-dashoffset", array: "stroke-dasharray" };
      var bl = { offset: "strokeDashoffset", array: "strokeDasharray" };
      function Ji(t2, e, o2 = 1, r = 0, n2 = true) {
        t2.pathLength = 1;
        let s2 = n2 ? Tl : bl;
        t2[s2.offset] = T.transform(-r);
        let i2 = T.transform(e), a = T.transform(o2);
        t2[s2.array] = `${i2} ${a}`;
      }
      function xe(t2, { attrX: e, attrY: o2, attrScale: r, originX: n2, originY: s2, pathLength: i2, pathSpacing: a = 1, pathOffset: c = 0, ...l2 }, u2, m2, f) {
        if (he(t2, l2, u2, f), m2) {
          t2.style.viewBox && (t2.attrs.viewBox = t2.style.viewBox);
          return;
        }
        t2.attrs = t2.style, t2.style = {};
        let { attrs: p2, style: d, dimensions: h } = t2;
        p2.transform && (h && (d.transform = p2.transform), delete p2.transform), h && (n2 !== void 0 || s2 !== void 0 || d.transform) && (d.transformOrigin = Zi(h, n2 !== void 0 ? n2 : 0.5, s2 !== void 0 ? s2 : 0.5)), e !== void 0 && (p2.x = e), o2 !== void 0 && (p2.y = o2), r !== void 0 && (p2.scale = r), i2 !== void 0 && Ji(p2, i2, a, c, false);
      }
      var _o = () => ({ ...ge(), attrs: {} });
      var ve = (t2) => typeof t2 == "string" && t2.toLowerCase() === "svg";
      function Qi(t2, e, o2, r) {
        let n2 = (0, import_react14.useMemo)(() => {
          let s2 = _o();
          return xe(s2, e, { enableHardwareAcceleration: false }, ve(r), t2.transformTemplate), { ...s2.attrs, style: { ...s2.style } };
        }, [e]);
        if (t2.style) {
          let s2 = {};
          un(s2, t2.style, t2), n2.style = { ...s2, ...n2.style };
        }
        return n2;
      }
      function ts(t2 = false) {
        return (o2, r, n2, { latestValues: s2 }, i2) => {
          let c = (fe(o2) ? Qi : Ki)(r, s2, i2, o2), u2 = { ...dn(r, typeof o2 == "string", t2), ...c, ref: n2 }, { children: m2 } = r, f = (0, import_react12.useMemo)(() => A(m2) ? m2.get() : m2, [m2]);
          return (0, import_react12.createElement)(o2, { ...u2, children: f });
        };
      }
      function Yo(t2, { style: e, vars: o2 }, r, n2) {
        Object.assign(t2.style, e, n2 && n2.getProjectionStyles(r));
        for (let s2 in o2)
          t2.style.setProperty(s2, o2[s2]);
      }
      var qo = /* @__PURE__ */ new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
      function Xo(t2, e, o2, r) {
        Yo(t2, e, void 0, r);
        for (let n2 in e.attrs)
          t2.setAttribute(qo.has(n2) ? n2 : Vt(n2), e.attrs[n2]);
      }
      function Se(t2, e) {
        let { style: o2 } = t2, r = {};
        for (let n2 in o2)
          (A(o2[n2]) || e.style && A(e.style[n2]) || Wo(n2, t2)) && (r[n2] = o2[n2]);
        return r;
      }
      function Zo(t2, e) {
        let o2 = Se(t2, e);
        for (let r in t2)
          if (A(t2[r]) || A(e[r])) {
            let n2 = Ot.indexOf(r) !== -1 ? "attr" + r.charAt(0).toUpperCase() + r.substring(1) : r;
            o2[n2] = t2[r];
          }
        return o2;
      }
      function Ve(t2, e, o2, r = {}, n2 = {}) {
        return typeof e == "function" && (e = e(o2 !== void 0 ? o2 : t2.custom, r, n2)), typeof e == "string" && (e = t2.variants && t2.variants[e]), typeof e == "function" && (e = e(o2 !== void 0 ? o2 : t2.custom, r, n2)), e;
      }
      function L(t2) {
        let e = (0, import_react16.useRef)(null);
        return e.current === null && (e.current = t2()), e.current;
      }
      var Yt = (t2) => Array.isArray(t2);
      var es = (t2) => !!(t2 && typeof t2 == "object" && t2.mix && t2.toValue);
      var os = (t2) => Yt(t2) ? t2[t2.length - 1] || 0 : t2;
      function qt(t2) {
        let e = A(t2) ? t2.get() : t2;
        return es(e) ? e.toValue() : e;
      }
      function Ml({ scrapeMotionValuesFromProps: t2, createRenderState: e, onMount: o2 }, r, n2, s2) {
        let i2 = { latestValues: El(r, n2, s2, t2), renderState: e() };
        return o2 && (i2.mount = (a) => o2(r, a, i2)), i2;
      }
      var Xt = (t2) => (e, o2) => {
        let r = (0, import_react15.useContext)(lt), n2 = (0, import_react15.useContext)(ft), s2 = () => Ml(t2, e, r, n2);
        return o2 ? s2() : L(s2);
      };
      function El(t2, e, o2, r) {
        let n2 = {}, s2 = r(t2, {});
        for (let f in s2)
          n2[f] = qt(s2[f]);
        let { initial: i2, animate: a } = t2, c = $t(t2), l2 = zo(t2);
        e && l2 && !c && t2.inherit !== false && (i2 === void 0 && (i2 = e.initial), a === void 0 && (a = e.animate));
        let u2 = o2 ? o2.initial === false : false;
        u2 = u2 || i2 === false;
        let m2 = u2 ? a : i2;
        return m2 && typeof m2 != "boolean" && !It(m2) && (Array.isArray(m2) ? m2 : [m2]).forEach((p2) => {
          let d = Ve(t2, p2);
          if (!d)
            return;
          let { transitionEnd: h, transition: y, ...S } = d;
          for (let x in S) {
            let g = S[x];
            if (Array.isArray(g)) {
              let v = u2 ? g.length - 1 : 0;
              g = g[v];
            }
            g !== null && (n2[x] = g);
          }
          for (let x in h)
            n2[x] = h[x];
        }), n2;
      }
      var w = (t2) => t2;
      var Jo = class {
        constructor() {
          this.order = [], this.scheduled = /* @__PURE__ */ new Set();
        }
        add(e) {
          if (!this.scheduled.has(e))
            return this.scheduled.add(e), this.order.push(e), true;
        }
        remove(e) {
          let o2 = this.order.indexOf(e);
          o2 !== -1 && (this.order.splice(o2, 1), this.scheduled.delete(e));
        }
        clear() {
          this.order.length = 0, this.scheduled.clear();
        }
      };
      function ns(t2) {
        let e = new Jo(), o2 = new Jo(), r = 0, n2 = false, s2 = false, i2 = /* @__PURE__ */ new WeakSet(), a = {
          schedule: (c, l2 = false, u2 = false) => {
            let m2 = u2 && n2, f = m2 ? e : o2;
            return l2 && i2.add(c), f.add(c) && m2 && n2 && (r = e.order.length), c;
          }, cancel: (c) => {
            o2.remove(c), i2.delete(c);
          }, process: (c) => {
            if (n2) {
              s2 = true;
              return;
            }
            if (n2 = true, [e, o2] = [o2, e], o2.clear(), r = e.order.length, r)
              for (let l2 = 0; l2 < r; l2++) {
                let u2 = e.order[l2];
                u2(c), i2.has(u2) && (a.schedule(u2), t2());
              }
            n2 = false, s2 && (s2 = false, a.process(c));
          }
        };
        return a;
      }
      var Te = ["prepare", "read", "update", "preRender", "render", "postRender"];
      var Rl = 40;
      function is(t2, e) {
        let o2 = false, r = true, n2 = { delta: 0, timestamp: 0, isProcessing: false }, s2 = Te.reduce((m2, f) => (m2[f] = ns(() => o2 = true), m2), {}), i2 = (m2) => s2[m2].process(n2), a = () => {
          let m2 = performance.now();
          o2 = false, n2.delta = r ? 1e3 / 60 : Math.max(Math.min(m2 - n2.timestamp, Rl), 1), n2.timestamp = m2, n2.isProcessing = true, Te.forEach(i2), n2.isProcessing = false, o2 && e && (r = false, t2(a));
        }, c = () => {
          o2 = true, r = true, n2.isProcessing || t2(a);
        };
        return {
          schedule: Te.reduce((m2, f) => {
            let p2 = s2[f];
            return m2[f] = (d, h = false, y = false) => (o2 || c(), p2.schedule(d, h, y)), m2;
          }, {}), cancel: (m2) => Te.forEach((f) => s2[f].cancel(m2)), state: n2, steps: s2
        };
      }
      var { schedule: V, cancel: O, state: F, steps: no } = is(typeof requestAnimationFrame < "u" ? requestAnimationFrame : w, true);
      var ss = {
        useVisualState: Xt({
          scrapeMotionValuesFromProps: Zo, createRenderState: _o, onMount: (t2, e, { renderState: o2, latestValues: r }) => {
            V.read(() => {
              try {
                o2.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
              } catch {
                o2.dimensions = { x: 0, y: 0, width: 0, height: 0 };
              }
            }), V.render(() => {
              xe(o2, r, { enableHardwareAcceleration: false }, ve(e.tagName), t2.transformTemplate), Xo(e, o2);
            });
          }
        })
      };
      var as = { useVisualState: Xt({ scrapeMotionValuesFromProps: Se, createRenderState: ge }) };
      function io(t2, { forwardMotionProps: e = false }, o2, r) {
        return { ...fe(t2) ? ss : as, preloadedFeatures: o2, useRender: ts(e), createVisualElement: r, Component: t2 };
      }
      function Y(t2, e, o2, r = { passive: true }) {
        return t2.addEventListener(e, o2, r), () => t2.removeEventListener(e, o2);
      }
      var Qo = (t2) => t2.pointerType === "mouse" ? typeof t2.button != "number" || t2.button <= 0 : t2.isPrimary !== false;
      function Zt(t2, e = "page") {
        return { point: { x: t2[e + "X"], y: t2[e + "Y"] } };
      }
      var hn = (t2) => (e) => Qo(e) && t2(e, Zt(e));
      function J(t2, e, o2, r) {
        return Y(t2, e, hn(o2), r);
      }
      var Dl = (t2, e) => (o2) => e(t2(o2));
      var Q = (...t2) => t2.reduce(Dl);
      function us(t2) {
        let e = null;
        return () => {
          let o2 = () => {
            e = null;
          };
          return e === null ? (e = t2, o2) : false;
        };
      }
      var cs = us("dragHorizontal");
      var ls = us("dragVertical");
      function gn(t2) {
        let e = false;
        if (t2 === "y")
          e = ls();
        else if (t2 === "x")
          e = cs();
        else {
          let o2 = cs(), r = ls();
          o2 && r ? e = () => {
            o2(), r();
          } : (o2 && o2(), r && r());
        }
        return e;
      }
      function so() {
        let t2 = gn(true);
        return t2 ? (t2(), false) : true;
      }
      var G = class {
        constructor(e) {
          this.isMounted = false, this.node = e;
        }
        update() {
        }
      };
      function ms(t2, e) {
        let o2 = "pointer" + (e ? "enter" : "leave"), r = "onHover" + (e ? "Start" : "End"), n2 = (s2, i2) => {
          if (s2.pointerType === "touch" || so())
            return;
          let a = t2.getProps();
          t2.animationState && a.whileHover && t2.animationState.setActive("whileHover", e), a[r] && V.update(() => a[r](s2, i2));
        };
        return J(t2.current, o2, n2, { passive: !t2.getProps()[r] });
      }
      var tr = class extends G {
        mount() {
          this.unmount = Q(ms(this.node, true), ms(this.node, false));
        }
        unmount() {
        }
      };
      var er = class extends G {
        constructor() {
          super(...arguments), this.isActive = false;
        }
        onFocus() {
          let e = false;
          try {
            e = this.node.current.matches(":focus-visible");
          } catch {
            e = true;
          }
          !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", true), this.isActive = true);
        }
        onBlur() {
          !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", false), this.isActive = false);
        }
        mount() {
          this.unmount = Q(Y(this.node.current, "focus", () => this.onFocus()), Y(this.node.current, "blur", () => this.onBlur()));
        }
        unmount() {
        }
      };
      var yn = (t2, e) => e ? t2 === e ? true : yn(t2, e.parentElement) : false;
      function xn(t2, e) {
        if (!e)
          return;
        let o2 = new PointerEvent("pointer" + t2);
        e(o2, Zt(o2));
      }
      var or = class extends G {
        constructor() {
          super(...arguments), this.removeStartListeners = w, this.removeEndListeners = w, this.removeAccessibleListeners = w, this.startPointerPress = (e, o2) => {
            if (this.isPressing)
              return;
            this.removeEndListeners();
            let r = this.node.getProps(), s2 = J(window, "pointerup", (a, c) => {
              if (!this.checkPressEnd())
                return;
              let { onTap: l2, onTapCancel: u2, globalTapTarget: m2 } = this.node.getProps();
              V.update(() => {
                !m2 && !yn(this.node.current, a.target) ? u2 && u2(a, c) : l2 && l2(a, c);
              });
            }, { passive: !(r.onTap || r.onPointerUp) }), i2 = J(window, "pointercancel", (a, c) => this.cancelPress(a, c), { passive: !(r.onTapCancel || r.onPointerCancel) });
            this.removeEndListeners = Q(s2, i2), this.startPress(e, o2);
          }, this.startAccessiblePress = () => {
            let e = (s2) => {
              if (s2.key !== "Enter" || this.isPressing)
                return;
              let i2 = (a) => {
                a.key !== "Enter" || !this.checkPressEnd() || xn("up", (c, l2) => {
                  let { onTap: u2 } = this.node.getProps();
                  u2 && V.update(() => u2(c, l2));
                });
              };
              this.removeEndListeners(), this.removeEndListeners = Y(this.node.current, "keyup", i2), xn("down", (a, c) => {
                this.startPress(a, c);
              });
            }, o2 = Y(this.node.current, "keydown", e), r = () => {
              this.isPressing && xn("cancel", (s2, i2) => this.cancelPress(s2, i2));
            }, n2 = Y(this.node.current, "blur", r);
            this.removeAccessibleListeners = Q(o2, n2);
          };
        }
        startPress(e, o2) {
          this.isPressing = true;
          let { onTapStart: r, whileTap: n2 } = this.node.getProps();
          n2 && this.node.animationState && this.node.animationState.setActive("whileTap", true), r && V.update(() => r(e, o2));
        }
        checkPressEnd() {
          return this.removeEndListeners(), this.isPressing = false, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", false), !so();
        }
        cancelPress(e, o2) {
          if (!this.checkPressEnd())
            return;
          let { onTapCancel: r } = this.node.getProps();
          r && V.update(() => r(e, o2));
        }
        mount() {
          let e = this.node.getProps(), o2 = J(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), r = Y(this.node.current, "focus", this.startAccessiblePress);
          this.removeStartListeners = Q(o2, r);
        }
        unmount() {
          this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
        }
      };
      var Sn = /* @__PURE__ */ new WeakMap();
      var vn = /* @__PURE__ */ new WeakMap();
      var Ll = (t2) => {
        let e = Sn.get(t2.target);
        e && e(t2);
      };
      var kl = (t2) => {
        t2.forEach(Ll);
      };
      function Il({ root: t2, ...e }) {
        let o2 = t2 || document;
        vn.has(o2) || vn.set(o2, {});
        let r = vn.get(o2), n2 = JSON.stringify(e);
        return r[n2] || (r[n2] = new IntersectionObserver(kl, { root: t2, ...e })), r[n2];
      }
      function fs(t2, e, o2) {
        let r = Il(e);
        return Sn.set(t2, o2), r.observe(t2), () => {
          Sn.delete(t2), r.unobserve(t2);
        };
      }
      var Ol = { some: 0, all: 1 };
      var rr = class extends G {
        constructor() {
          super(...arguments), this.hasEnteredView = false, this.isInView = false;
        }
        startObserver() {
          this.unmount();
          let { viewport: e = {} } = this.node.getProps(), { root: o2, margin: r, amount: n2 = "some", once: s2 } = e, i2 = { root: o2 ? o2.current : void 0, rootMargin: r, threshold: typeof n2 == "number" ? n2 : Ol[n2] }, a = (c) => {
            let { isIntersecting: l2 } = c;
            if (this.isInView === l2 || (this.isInView = l2, s2 && !l2 && this.hasEnteredView))
              return;
            l2 && (this.hasEnteredView = true), this.node.animationState && this.node.animationState.setActive("whileInView", l2);
            let { onViewportEnter: u2, onViewportLeave: m2 } = this.node.getProps(), f = l2 ? u2 : m2;
            f && f(c);
          };
          return fs(this.node.current, i2, a);
        }
        mount() {
          this.startObserver();
        }
        update() {
          if (typeof IntersectionObserver > "u")
            return;
          let { props: e, prevProps: o2 } = this.node;
          ["amount", "margin", "root"].some(Fl(e, o2)) && this.startObserver();
        }
        unmount() {
        }
      };
      function Fl({ viewport: t2 = {} }, { viewport: e = {} } = {}) {
        return (o2) => t2[o2] !== e[o2];
      }
      var nr = { inView: { Feature: rr }, tap: { Feature: or }, focus: { Feature: er }, hover: { Feature: tr } };
      function Vn(t2, e) {
        if (!Array.isArray(e))
          return false;
        let o2 = e.length;
        if (o2 !== t2.length)
          return false;
        for (let r = 0; r < o2; r++)
          if (e[r] !== t2[r])
            return false;
        return true;
      }
      function Bl(t2) {
        let e = {};
        return t2.values.forEach((o2, r) => e[r] = o2.get()), e;
      }
      function jl(t2) {
        let e = {};
        return t2.values.forEach((o2, r) => e[r] = o2.getVelocity()), e;
      }
      function jt(t2, e, o2) {
        let r = t2.getProps();
        return Ve(r, e, o2 !== void 0 ? o2 : r.custom, Bl(t2), jl(t2));
      }
      var ut = w;
      var E = w;
      var tt = (t2) => t2 * 1e3;
      var H = (t2) => t2 / 1e3;
      var Jt = { current: false };
      var Tn = (t2) => Array.isArray(t2) && typeof t2[0] == "number";
      function bn(t2) {
        return !!(!t2 || typeof t2 == "string" && ps[t2] || Tn(t2) || Array.isArray(t2) && t2.every(bn));
      }
      var ao = ([t2, e, o2, r]) => `cubic-bezier(${t2}, ${e}, ${o2}, ${r})`;
      var ps = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: ao([0, 0.65, 0.55, 1]), circOut: ao([0.55, 0, 1, 0.45]), backIn: ao([0.31, 0.01, 0.66, -0.59]), backOut: ao([0.33, 1.53, 0.69, 0.99]) };
      function Pn(t2) {
        if (t2)
          return Tn(t2) ? ao(t2) : Array.isArray(t2) ? t2.map(Pn) : ps[t2];
      }
      function co(t2, e, o2, { delay: r = 0, duration: n2, repeat: s2 = 0, repeatType: i2 = "loop", ease: a, times: c } = {}) {
        let l2 = { [e]: o2 };
        c && (l2.offset = c);
        let u2 = Pn(a);
        return Array.isArray(u2) && (l2.easing = u2), t2.animate(l2, { delay: r, duration: n2, easing: Array.isArray(u2) ? "linear" : u2, fill: "both", iterations: s2 + 1, direction: i2 === "reverse" ? "alternate" : "normal" });
      }
      function ds(t2, { repeat: e, repeatType: o2 = "loop" }) {
        let r = e && o2 !== "loop" && e % 2 === 1 ? 0 : t2.length - 1;
        return t2[r];
      }
      var hs = (t2, e, o2) => (((1 - 3 * o2 + 3 * e) * t2 + (3 * o2 - 6 * e)) * t2 + 3 * e) * t2;
      var Nl = 1e-7;
      var Ul = 12;
      function zl(t2, e, o2, r, n2) {
        let s2, i2, a = 0;
        do
          i2 = e + (o2 - e) / 2, s2 = hs(i2, r, n2) - t2, s2 > 0 ? o2 = i2 : e = i2;
        while (Math.abs(s2) > Nl && ++a < Ul);
        return i2;
      }
      function Ct(t2, e, o2, r) {
        if (t2 === e && o2 === r)
          return w;
        let n2 = (s2) => zl(s2, 0, 1, t2, o2);
        return (s2) => s2 === 0 || s2 === 1 ? s2 : hs(n2(s2), e, r);
      }
      var Cn = Ct(0.42, 0, 1, 1);
      var An = Ct(0, 0, 0.58, 1);
      var lo = Ct(0.42, 0, 0.58, 1);
      var ir = (t2) => Array.isArray(t2) && typeof t2[0] != "number";
      var uo = (t2) => (e) => e <= 0.5 ? t2(2 * e) / 2 : (2 - t2(2 * (1 - e))) / 2;
      var mo = (t2) => (e) => 1 - t2(1 - e);
      var fo = (t2) => 1 - Math.sin(Math.acos(t2));
      var po = mo(fo);
      var wn = uo(fo);
      var sr = Ct(0.33, 1.53, 0.69, 0.99);
      var be = mo(sr);
      var Mn = uo(be);
      var En = (t2) => (t2 *= 2) < 1 ? 0.5 * be(t2) : 0.5 * (2 - Math.pow(2, -10 * (t2 - 1)));
      var gs = { linear: w, easeIn: Cn, easeInOut: lo, easeOut: An, circIn: fo, circInOut: wn, circOut: po, backIn: be, backInOut: Mn, backOut: sr, anticipate: En };
      var ho = (t2) => {
        if (Array.isArray(t2)) {
          E(t2.length === 4, "Cubic bezier arrays must contain four numerical values.");
          let [e, o2, r, n2] = t2;
          return Ct(e, o2, r, n2);
        } else if (typeof t2 == "string")
          return E(gs[t2] !== void 0, `Invalid easing type '${t2}'`), gs[t2];
        return t2;
      };
      var Pe = (t2, e) => (o2) => !!(Pt(o2) && Hi.test(o2) && o2.startsWith(t2) || e && Object.prototype.hasOwnProperty.call(o2, e));
      var ar = (t2, e, o2) => (r) => {
        if (!Pt(r))
          return r;
        let [n2, s2, i2, a] = r.match(_t);
        return { [t2]: parseFloat(n2), [e]: parseFloat(s2), [o2]: parseFloat(i2), alpha: a !== void 0 ? parseFloat(a) : 1 };
      };
      var Gl = (t2) => _(0, 255, t2);
      var Rn = { ...at, transform: (t2) => Math.round(Gl(t2)) };
      var ht = { test: Pe("rgb", "red"), parse: ar("red", "green", "blue"), transform: ({ red: t2, green: e, blue: o2, alpha: r = 1 }) => "rgba(" + Rn.transform(t2) + ", " + Rn.transform(e) + ", " + Rn.transform(o2) + ", " + Bt(Ft.transform(r)) + ")" };
      function Hl(t2) {
        let e = "", o2 = "", r = "", n2 = "";
        return t2.length > 5 ? (e = t2.substring(1, 3), o2 = t2.substring(3, 5), r = t2.substring(5, 7), n2 = t2.substring(7, 9)) : (e = t2.substring(1, 2), o2 = t2.substring(2, 3), r = t2.substring(3, 4), n2 = t2.substring(4, 5), e += e, o2 += o2, r += r, n2 += n2), { red: parseInt(e, 16), green: parseInt(o2, 16), blue: parseInt(r, 16), alpha: n2 ? parseInt(n2, 16) / 255 : 1 };
      }
      var go = { test: Pe("#"), parse: Hl, transform: ht.transform };
      var Nt = { test: Pe("hsl", "hue"), parse: ar("hue", "saturation", "lightness"), transform: ({ hue: t2, saturation: e, lightness: o2, alpha: r = 1 }) => "hsla(" + Math.round(t2) + ", " + Z.transform(Bt(e)) + ", " + Z.transform(Bt(o2)) + ", " + Bt(Ft.transform(r)) + ")" };
      var j = { test: (t2) => ht.test(t2) || go.test(t2) || Nt.test(t2), parse: (t2) => ht.test(t2) ? ht.parse(t2) : Nt.test(t2) ? Nt.parse(t2) : go.parse(t2), transform: (t2) => Pt(t2) ? t2 : t2.hasOwnProperty("red") ? ht.transform(t2) : Nt.transform(t2) };
      var C = (t2, e, o2) => -o2 * t2 + o2 * e + t2;
      function Dn(t2, e, o2) {
        return o2 < 0 && (o2 += 1), o2 > 1 && (o2 -= 1), o2 < 1 / 6 ? t2 + (e - t2) * 6 * o2 : o2 < 1 / 2 ? e : o2 < 2 / 3 ? t2 + (e - t2) * (2 / 3 - o2) * 6 : t2;
      }
      function ys({ hue: t2, saturation: e, lightness: o2, alpha: r }) {
        t2 /= 360, e /= 100, o2 /= 100;
        let n2 = 0, s2 = 0, i2 = 0;
        if (!e)
          n2 = s2 = i2 = o2;
        else {
          let a = o2 < 0.5 ? o2 * (1 + e) : o2 + e - o2 * e, c = 2 * o2 - a;
          n2 = Dn(c, a, t2 + 1 / 3), s2 = Dn(c, a, t2), i2 = Dn(c, a, t2 - 1 / 3);
        }
        return { red: Math.round(n2 * 255), green: Math.round(s2 * 255), blue: Math.round(i2 * 255), alpha: r };
      }
      var Ln = (t2, e, o2) => {
        let r = t2 * t2;
        return Math.sqrt(Math.max(0, o2 * (e * e - r) + r));
      };
      var Wl = [go, ht, Nt];
      var $l = (t2) => Wl.find((e) => e.test(t2));
      function xs(t2) {
        let e = $l(t2);
        E(!!e, `'${t2}' is not an animatable color. Use the equivalent color code instead.`);
        let o2 = e.parse(t2);
        return e === Nt && (o2 = ys(o2)), o2;
      }
      var cr = (t2, e) => {
        let o2 = xs(t2), r = xs(e), n2 = { ...o2 };
        return (s2) => (n2.red = Ln(o2.red, r.red, s2), n2.green = Ln(o2.green, r.green, s2), n2.blue = Ln(o2.blue, r.blue, s2), n2.alpha = C(o2.alpha, r.alpha, s2), ht.transform(n2));
      };
      function Kl(t2) {
        var e, o2;
        return isNaN(t2) && Pt(t2) && (((e = t2.match(_t)) === null || e === void 0 ? void 0 : e.length) || 0) + (((o2 = t2.match(an)) === null || o2 === void 0 ? void 0 : o2.length) || 0) > 0;
      }
      var vs = { regex: zi, countKey: "Vars", token: "${v}", parse: w };
      var Ss = { regex: an, countKey: "Colors", token: "${c}", parse: j.parse };
      var Vs = { regex: _t, countKey: "Numbers", token: "${n}", parse: at.parse };
      function kn(t2, { regex: e, countKey: o2, token: r, parse: n2 }) {
        let s2 = t2.tokenised.match(e);
        s2 && (t2["num" + o2] = s2.length, t2.tokenised = t2.tokenised.replace(e, r), t2.values.push(...s2.map(n2)));
      }
      function yo(t2) {
        let e = t2.toString(), o2 = { value: e, tokenised: e, values: [], numVars: 0, numColors: 0, numNumbers: 0 };
        return o2.value.includes("var(--") && kn(o2, vs), kn(o2, Ss), kn(o2, Vs), o2;
      }
      function Ts(t2) {
        return yo(t2).values;
      }
      function bs(t2) {
        let { values: e, numColors: o2, numVars: r, tokenised: n2 } = yo(t2), s2 = e.length;
        return (i2) => {
          let a = n2;
          for (let c = 0; c < s2; c++)
            c < r ? a = a.replace(vs.token, i2[c]) : c < r + o2 ? a = a.replace(Ss.token, j.transform(i2[c])) : a = a.replace(Vs.token, Bt(i2[c]));
          return a;
        };
      }
      var _l = (t2) => typeof t2 == "number" ? 0 : t2;
      function Yl(t2) {
        let e = Ts(t2);
        return bs(t2)(e.map(_l));
      }
      var q = { test: Kl, parse: Ts, createTransformer: bs, getAnimatableNone: Yl };
      var Ps = (t2, e) => (o2) => `${o2 > 0 ? e : t2}`;
      function Cs(t2, e) {
        return typeof t2 == "number" ? (o2) => C(t2, e, o2) : j.test(t2) ? cr(t2, e) : t2.startsWith("var(") ? Ps(t2, e) : On(t2, e);
      }
      var In = (t2, e) => {
        let o2 = [...t2], r = o2.length, n2 = t2.map((s2, i2) => Cs(s2, e[i2]));
        return (s2) => {
          for (let i2 = 0; i2 < r; i2++)
            o2[i2] = n2[i2](s2);
          return o2;
        };
      };
      var As = (t2, e) => {
        let o2 = { ...t2, ...e }, r = {};
        for (let n2 in o2)
          t2[n2] !== void 0 && e[n2] !== void 0 && (r[n2] = Cs(t2[n2], e[n2]));
        return (n2) => {
          for (let s2 in r)
            o2[s2] = r[s2](n2);
          return o2;
        };
      };
      var On = (t2, e) => {
        let o2 = q.createTransformer(e), r = yo(t2), n2 = yo(e);
        return r.numVars === n2.numVars && r.numColors === n2.numColors && r.numNumbers >= n2.numNumbers ? Q(In(r.values, n2.values), o2) : (ut(true, `Complex values '${t2}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Ps(t2, e));
      };
      var et = (t2, e, o2) => {
        let r = e - t2;
        return r === 0 ? 1 : (o2 - t2) / r;
      };
      var ws = (t2, e) => (o2) => C(t2, e, o2);
      function ql(t2) {
        return typeof t2 == "number" ? ws : typeof t2 == "string" ? j.test(t2) ? cr : On : Array.isArray(t2) ? In : typeof t2 == "object" ? As : ws;
      }
      function Xl(t2, e, o2) {
        let r = [], n2 = o2 || ql(t2[0]), s2 = t2.length - 1;
        for (let i2 = 0; i2 < s2; i2++) {
          let a = n2(t2[i2], t2[i2 + 1]);
          if (e) {
            let c = Array.isArray(e) ? e[i2] || w : e;
            a = Q(c, a);
          }
          r.push(a);
        }
        return r;
      }
      function At(t2, e, { clamp: o2 = true, ease: r, mixer: n2 } = {}) {
        let s2 = t2.length;
        if (E(s2 === e.length, "Both input and output ranges must be the same length"), s2 === 1)
          return () => e[0];
        t2[0] > t2[s2 - 1] && (t2 = [...t2].reverse(), e = [...e].reverse());
        let i2 = Xl(e, r, n2), a = i2.length, c = (l2) => {
          let u2 = 0;
          if (a > 1)
            for (; u2 < t2.length - 2 && !(l2 < t2[u2 + 1]); u2++)
              ;
          let m2 = et(t2[u2], t2[u2 + 1], l2);
          return i2[u2](m2);
        };
        return o2 ? (l2) => c(_(t2[0], t2[s2 - 1], l2)) : c;
      }
      function lr(t2, e) {
        let o2 = t2[t2.length - 1];
        for (let r = 1; r <= e; r++) {
          let n2 = et(0, e, r);
          t2.push(C(o2, 1, n2));
        }
      }
      function Ce(t2) {
        let e = [0];
        return lr(e, t2.length - 1), e;
      }
      function Ms(t2, e) {
        return t2.map((o2) => o2 * e);
      }
      function Zl(t2, e) {
        return t2.map(() => e || lo).splice(0, t2.length - 1);
      }
      function xo({ duration: t2 = 300, keyframes: e, times: o2, ease: r = "easeInOut" }) {
        let n2 = ir(r) ? r.map(ho) : ho(r), s2 = { done: false, value: e[0] }, i2 = Ms(o2 && o2.length === e.length ? o2 : Ce(e), t2), a = At(i2, e, { ease: Array.isArray(n2) ? n2 : Zl(e, n2) });
        return { calculatedDuration: t2, next: (c) => (s2.value = a(c), s2.done = c >= t2, s2) };
      }
      function Ae(t2, e) {
        return e ? t2 * (1e3 / e) : 0;
      }
      var Jl = 5;
      function ur(t2, e, o2) {
        let r = Math.max(e - Jl, 0);
        return Ae(o2 - t2(r), e - r);
      }
      var Fn = 1e-3;
      var Ql = 0.01;
      var Es = 10;
      var tu = 0.05;
      var eu = 1;
      function Rs({ duration: t2 = 800, bounce: e = 0.25, velocity: o2 = 0, mass: r = 1 }) {
        let n2, s2;
        ut(t2 <= tt(Es), "Spring duration must be 10 seconds or less");
        let i2 = 1 - e;
        i2 = _(tu, eu, i2), t2 = _(Ql, Es, H(t2)), i2 < 1 ? (n2 = (l2) => {
          let u2 = l2 * i2, m2 = u2 * t2, f = u2 - o2, p2 = mr(l2, i2), d = Math.exp(-m2);
          return Fn - f / p2 * d;
        }, s2 = (l2) => {
          let m2 = l2 * i2 * t2, f = m2 * o2 + o2, p2 = Math.pow(i2, 2) * Math.pow(l2, 2) * t2, d = Math.exp(-m2), h = mr(Math.pow(l2, 2), i2);
          return (-n2(l2) + Fn > 0 ? -1 : 1) * ((f - p2) * d) / h;
        }) : (n2 = (l2) => {
          let u2 = Math.exp(-l2 * t2), m2 = (l2 - o2) * t2 + 1;
          return -Fn + u2 * m2;
        }, s2 = (l2) => {
          let u2 = Math.exp(-l2 * t2), m2 = (o2 - l2) * (t2 * t2);
          return u2 * m2;
        });
        let a = 5 / t2, c = ru(n2, s2, a);
        if (t2 = tt(t2), isNaN(c))
          return { stiffness: 100, damping: 10, duration: t2 };
        {
          let l2 = Math.pow(c, 2) * r;
          return { stiffness: l2, damping: i2 * 2 * Math.sqrt(r * l2), duration: t2 };
        }
      }
      var ou = 12;
      function ru(t2, e, o2) {
        let r = o2;
        for (let n2 = 1; n2 < ou; n2++)
          r = r - t2(r) / e(r);
        return r;
      }
      function mr(t2, e) {
        return t2 * Math.sqrt(1 - e * e);
      }
      var nu = ["duration", "bounce"];
      var iu = ["stiffness", "damping", "mass"];
      function Ds(t2, e) {
        return e.some((o2) => t2[o2] !== void 0);
      }
      function su(t2) {
        let e = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false, ...t2 };
        if (!Ds(t2, iu) && Ds(t2, nu)) {
          let o2 = Rs(t2);
          e = { ...e, ...o2, mass: 1 }, e.isResolvedFromDuration = true;
        }
        return e;
      }
      function Qt({ keyframes: t2, restDelta: e, restSpeed: o2, ...r }) {
        let n2 = t2[0], s2 = t2[t2.length - 1], i2 = { done: false, value: n2 }, { stiffness: a, damping: c, mass: l2, duration: u2, velocity: m2, isResolvedFromDuration: f } = su({ ...r, velocity: -H(r.velocity || 0) }), p2 = m2 || 0, d = c / (2 * Math.sqrt(a * l2)), h = s2 - n2, y = H(Math.sqrt(a / l2)), S = Math.abs(h) < 5;
        o2 || (o2 = S ? 0.01 : 2), e || (e = S ? 5e-3 : 0.5);
        let x;
        if (d < 1) {
          let g = mr(y, d);
          x = (v) => {
            let P = Math.exp(-d * y * v);
            return s2 - P * ((p2 + d * y * h) / g * Math.sin(g * v) + h * Math.cos(g * v));
          };
        } else if (d === 1)
          x = (g) => s2 - Math.exp(-y * g) * (h + (p2 + y * h) * g);
        else {
          let g = y * Math.sqrt(d * d - 1);
          x = (v) => {
            let P = Math.exp(-d * y * v), R = Math.min(g * v, 300);
            return s2 - P * ((p2 + d * y * h) * Math.sinh(R) + g * h * Math.cosh(R)) / g;
          };
        }
        return {
          calculatedDuration: f && u2 || null, next: (g) => {
            let v = x(g);
            if (f)
              i2.done = g >= u2;
            else {
              let P = p2;
              g !== 0 && (d < 1 ? P = ur(x, g, v) : P = 0);
              let R = Math.abs(P) <= o2, D = Math.abs(s2 - v) <= e;
              i2.done = R && D;
            }
            return i2.value = i2.done ? s2 : v, i2;
          }
        };
      }
      function Bn({ keyframes: t2, velocity: e = 0, power: o2 = 0.8, timeConstant: r = 325, bounceDamping: n2 = 10, bounceStiffness: s2 = 500, modifyTarget: i2, min: a, max: c, restDelta: l2 = 0.5, restSpeed: u2 }) {
        let m2 = t2[0], f = { done: false, value: m2 }, p2 = (b) => a !== void 0 && b < a || c !== void 0 && b > c, d = (b) => a === void 0 ? c : c === void 0 || Math.abs(a - b) < Math.abs(c - b) ? a : c, h = o2 * e, y = m2 + h, S = i2 === void 0 ? y : i2(y);
        S !== y && (h = S - m2);
        let x = (b) => -h * Math.exp(-b / r), g = (b) => S + x(b), v = (b) => {
          let M = x(b), U = g(b);
          f.done = Math.abs(M) <= l2, f.value = f.done ? S : U;
        }, P, R, D = (b) => {
          p2(f.value) && (P = b, R = Qt({ keyframes: [f.value, d(f.value)], velocity: ur(g, b, f.value), damping: n2, stiffness: s2, restDelta: l2, restSpeed: u2 }));
        };
        return D(0), {
          calculatedDuration: null, next: (b) => {
            let M = false;
            return !R && P === void 0 && (M = true, v(b), D(b)), P !== void 0 && b > P ? R.next(b - P) : (!M && v(b), f);
          }
        };
      }
      var Ls = (t2) => {
        let e = ({ timestamp: o2 }) => t2(o2);
        return { start: () => V.update(e, true), stop: () => O(e), now: () => F.isProcessing ? F.timestamp : performance.now() };
      };
      function vo(t2) {
        let e = 0, o2 = 50, r = t2.next(e);
        for (; !r.done && e < 2e4;)
          e += o2, r = t2.next(e);
        return e >= 2e4 ? 1 / 0 : e;
      }
      var au = { decay: Bn, inertia: Bn, tween: xo, keyframes: xo, spring: Qt };
      function gt({ autoplay: t2 = true, delay: e = 0, driver: o2 = Ls, keyframes: r, type: n2 = "keyframes", repeat: s2 = 0, repeatDelay: i2 = 0, repeatType: a = "loop", onPlay: c, onStop: l2, onComplete: u2, onUpdate: m2, ...f }) {
        let p2 = 1, d = false, h, y, S = () => {
          y = new Promise((I) => {
            h = I;
          });
        };
        S();
        let x, g = au[n2] || xo, v;
        g !== xo && typeof r[0] != "number" && (v = At([0, 100], r, { clamp: false }), r = [0, 100]);
        let P = g({ ...f, keyframes: r }), R;
        a === "mirror" && (R = g({ ...f, keyframes: [...r].reverse(), velocity: -(f.velocity || 0) }));
        let D = "idle", b = null, M = null, U = null;
        P.calculatedDuration === null && s2 && (P.calculatedDuration = vo(P));
        let { calculatedDuration: Dt } = P, nt = 1 / 0, st = 1 / 0;
        Dt !== null && (nt = Dt + i2, st = nt * (s2 + 1) - i2);
        let B = 0, xt = (I) => {
          if (M === null)
            return;
          p2 > 0 && (M = Math.min(M, I)), p2 < 0 && (M = Math.min(I - st / p2, M)), b !== null ? B = b : B = Math.round(I - M) * p2;
          let kt = B - e * (p2 >= 0 ? 1 : -1), Bo = p2 >= 0 ? kt < 0 : kt > st;
          B = Math.max(kt, 0), D === "finished" && b === null && (B = st);
          let Mi = B, Ei = P;
          if (s2) {
            let en = Math.min(B, st) / nt, jo = Math.floor(en), Wt = en % 1;
            !Wt && en >= 1 && (Wt = 1), Wt === 1 && jo--, jo = Math.min(jo, s2 + 1), !!(jo % 2) && (a === "reverse" ? (Wt = 1 - Wt, i2 && (Wt -= i2 / nt)) : a === "mirror" && (Ei = R)), Mi = _(0, 1, Wt) * nt;
          }
          let Xe = Bo ? { done: false, value: r[0] } : Ei.next(Mi);
          v && (Xe.value = v(Xe.value));
          let { done: Ri } = Xe;
          !Bo && Dt !== null && (Ri = p2 >= 0 ? B >= st : B <= 0);
          let qc = b === null && (D === "finished" || D === "running" && Ri);
          return m2 && m2(Xe.value), qc && Lt(), Xe;
        }, N = () => {
          x && x.stop(), x = void 0;
        }, ct = () => {
          D = "idle", N(), h(), S(), M = U = null;
        }, Lt = () => {
          D = "finished", u2 && u2(), N(), h();
        }, vt = () => {
          if (d)
            return;
          x || (x = o2(xt));
          let I = x.now();
          c && c(), b !== null ? M = I - b : (!M || D === "finished") && (M = I), D === "finished" && S(), U = M, b = null, D = "running", x.start();
        };
        t2 && vt();
        let qe = {
          then(I, kt) {
            return y.then(I, kt);
          }, get time() {
            return H(B);
          }, set time(I) {
            I = tt(I), B = I, b !== null || !x || p2 === 0 ? b = I : M = x.now() - I / p2;
          }, get duration() {
            let I = P.calculatedDuration === null ? vo(P) : P.calculatedDuration;
            return H(I);
          }, get speed() {
            return p2;
          }, set speed(I) {
            I === p2 || !x || (p2 = I, qe.time = H(B));
          }, get state() {
            return D;
          }, play: vt, pause: () => {
            D = "paused", b = B;
          }, stop: () => {
            d = true, D !== "idle" && (D = "idle", l2 && l2(), ct());
          }, cancel: () => {
            U !== null && xt(U), ct();
          }, complete: () => {
            D = "finished";
          }, sample: (I) => (M = 0, xt(I))
        };
        return qe;
      }
      function fr(t2) {
        let e;
        return () => (e === void 0 && (e = t2()), e);
      }
      var cu = fr(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
      var lu = /* @__PURE__ */ new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"]);
      var pr = 10;
      var uu = 2e4;
      var mu = (t2, e) => e.type === "spring" || t2 === "backgroundColor" || !bn(e.ease);
      function ks(t2, e, { onUpdate: o2, onComplete: r, ...n2 }) {
        if (!(cu() && lu.has(e) && !n2.repeatDelay && n2.repeatType !== "mirror" && n2.damping !== 0 && n2.type !== "inertia"))
          return false;
        let i2 = false, a, c, l2 = false, u2 = () => {
          c = new Promise((g) => {
            a = g;
          });
        };
        u2();
        let { keyframes: m2, duration: f = 300, ease: p2, times: d } = n2;
        if (mu(e, n2)) {
          let g = gt({ ...n2, repeat: 0, delay: 0 }), v = { done: false, value: m2[0] }, P = [], R = 0;
          for (; !v.done && R < uu;)
            v = g.sample(R), P.push(v.value), R += pr;
          d = void 0, m2 = P, f = R - pr, p2 = "linear";
        }
        let h = co(t2.owner.current, e, m2, { ...n2, duration: f, ease: p2, times: d }), y = () => {
          l2 = false, h.cancel();
        }, S = () => {
          l2 = true, V.update(y), a(), u2();
        };
        return h.onfinish = () => {
          l2 || (t2.set(ds(m2, n2)), r && r(), S());
        }, {
          then(g, v) {
            return c.then(g, v);
          }, attachTimeline(g) {
            return h.timeline = g, h.onfinish = null, w;
          }, get time() {
            return H(h.currentTime || 0);
          }, set time(g) {
            h.currentTime = tt(g);
          }, get speed() {
            return h.playbackRate;
          }, set speed(g) {
            h.playbackRate = g;
          }, get duration() {
            return H(f);
          }, play: () => {
            i2 || (h.play(), O(y));
          }, pause: () => h.pause(), stop: () => {
            if (i2 = true, h.playState === "idle")
              return;
            let { currentTime: g } = h;
            if (g) {
              let v = gt({ ...n2, autoplay: false });
              t2.setWithVelocity(v.sample(g - pr).value, v.sample(g).value, pr);
            }
            S();
          }, complete: () => {
            l2 || h.finish();
          }, cancel: S
        };
      }
      function Is({ keyframes: t2, delay: e, onUpdate: o2, onComplete: r }) {
        let n2 = () => (o2 && o2(t2[t2.length - 1]), r && r(), { time: 0, speed: 1, duration: 0, play: w, pause: w, stop: w, then: (s2) => (s2(), Promise.resolve()), cancel: w, complete: w });
        return e ? gt({ keyframes: [0, 1], duration: 0, delay: e, onComplete: n2 }) : n2();
      }
      var fu = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 };
      var pu = (t2) => ({ type: "spring", stiffness: 550, damping: t2 === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 });
      var du = { type: "keyframes", duration: 0.8 };
      var hu = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 };
      var Os = (t2, { keyframes: e }) => e.length > 2 ? du : z.has(t2) ? t2.startsWith("scale") ? pu(e[1]) : fu : hu;
      var So = (t2, e) => t2 === "zIndex" ? false : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (q.test(e) || e === "0") && !e.startsWith("url("));
      var gu = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
      function yu(t2) {
        let [e, o2] = t2.slice(0, -1).split("(");
        if (e === "drop-shadow")
          return t2;
        let [r] = o2.match(_t) || [];
        if (!r)
          return t2;
        let n2 = o2.replace(r, ""), s2 = gu.has(e) ? 1 : 0;
        return r !== o2 && (s2 *= 100), e + "(" + s2 + n2 + ")";
      }
      var xu = /([a-z-]*)\(.*?\)/g;
      var Vo = {
        ...q, getAnimatableNone: (t2) => {
          let e = t2.match(xu);
          return e ? e.map(yu).join(" ") : t2;
        }
      };
      var vu = { ...Ko, color: j, backgroundColor: j, outlineColor: j, fill: j, stroke: j, borderColor: j, borderTopColor: j, borderRightColor: j, borderBottomColor: j, borderLeftColor: j, filter: Vo, WebkitFilter: Vo };
      var we = (t2) => vu[t2];
      function dr(t2, e) {
        let o2 = we(t2);
        return o2 !== Vo && (o2 = q), o2.getAnimatableNone ? o2.getAnimatableNone(e) : void 0;
      }
      var hr = (t2) => /^0[^.\s]+$/.test(t2);
      function Fs(t2) {
        if (typeof t2 == "number")
          return t2 === 0;
        if (t2 !== null)
          return t2 === "none" || t2 === "0" || hr(t2);
      }
      function Bs(t2, e, o2, r) {
        let n2 = So(e, o2), s2;
        Array.isArray(o2) ? s2 = [...o2] : s2 = [null, o2];
        let i2 = r.from !== void 0 ? r.from : t2.get(), a, c = [];
        for (let l2 = 0; l2 < s2.length; l2++)
          s2[l2] === null && (s2[l2] = l2 === 0 ? i2 : s2[l2 - 1]), Fs(s2[l2]) && c.push(l2), typeof s2[l2] == "string" && s2[l2] !== "none" && s2[l2] !== "0" && (a = s2[l2]);
        if (n2 && c.length && a)
          for (let l2 = 0; l2 < c.length; l2++) {
            let u2 = c[l2];
            s2[u2] = dr(e, a);
          }
        return s2;
      }
      function js({ when: t2, delay: e, delayChildren: o2, staggerChildren: r, staggerDirection: n2, repeat: s2, repeatType: i2, repeatDelay: a, from: c, elapsed: l2, ...u2 }) {
        return !!Object.keys(u2).length;
      }
      function Me(t2, e) {
        return t2[e] || t2.default || t2;
      }
      var jn = { skipAnimations: false };
      var Ee = (t2, e, o2, r = {}) => (n2) => {
        let s2 = Me(r, t2) || {}, i2 = s2.delay || r.delay || 0, { elapsed: a = 0 } = r;
        a = a - tt(i2);
        let c = Bs(e, t2, o2, s2), l2 = c[0], u2 = c[c.length - 1], m2 = So(t2, l2), f = So(t2, u2);
        ut(m2 === f, `You are trying to animate ${t2} from "${l2}" to "${u2}". ${l2} is not an animatable value - to enable this animation set ${l2} to a value animatable to ${u2} via the \`style\` property.`);
        let p2 = {
          keyframes: c, velocity: e.getVelocity(), ease: "easeOut", ...s2, delay: -a, onUpdate: (d) => {
            e.set(d), s2.onUpdate && s2.onUpdate(d);
          }, onComplete: () => {
            n2(), s2.onComplete && s2.onComplete();
          }
        };
        if (js(s2) || (p2 = { ...p2, ...Os(t2, p2) }), p2.duration && (p2.duration = tt(p2.duration)), p2.repeatDelay && (p2.repeatDelay = tt(p2.repeatDelay)), !m2 || !f || Jt.current || s2.type === false || jn.skipAnimations)
          return Is(Jt.current ? { ...p2, delay: 0 } : p2);
        if (!r.isHandoff && e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) {
          let d = ks(e, t2, p2);
          if (d)
            return d;
        }
        return gt(p2);
      };
      function te(t2) {
        return !!(A(t2) && t2.add);
      }
      var gr = (t2) => /^\-?\d*\.?\d+$/.test(t2);
      function Ut(t2, e) {
        t2.indexOf(e) === -1 && t2.push(e);
      }
      function mt(t2, e) {
        let o2 = t2.indexOf(e);
        o2 > -1 && t2.splice(o2, 1);
      }
      function Ns([...t2], e, o2) {
        let r = e < 0 ? t2.length + e : e;
        if (r >= 0 && r < t2.length) {
          let n2 = o2 < 0 ? t2.length + o2 : o2, [s2] = t2.splice(e, 1);
          t2.splice(n2, 0, s2);
        }
        return t2;
      }
      var zt = class {
        constructor() {
          this.subscriptions = [];
        }
        add(e) {
          return Ut(this.subscriptions, e), () => mt(this.subscriptions, e);
        }
        notify(e, o2, r) {
          let n2 = this.subscriptions.length;
          if (n2)
            if (n2 === 1)
              this.subscriptions[0](e, o2, r);
            else
              for (let s2 = 0; s2 < n2; s2++) {
                let i2 = this.subscriptions[s2];
                i2 && i2(e, o2, r);
              }
        }
        getSize() {
          return this.subscriptions.length;
        }
        clear() {
          this.subscriptions.length = 0;
        }
      };
      var Su = (t2) => !isNaN(parseFloat(t2));
      var Re = { current: void 0 };
      var De = class {
        constructor(e, o2 = {}) {
          this.version = "10.18.0", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = false, this.events = {}, this.updateAndNotify = (r, n2 = true) => {
            this.prev = this.current, this.current = r;
            let { delta: s2, timestamp: i2 } = F;
            this.lastUpdated !== i2 && (this.timeDelta = s2, this.lastUpdated = i2, V.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), n2 && this.events.renderRequest && this.events.renderRequest.notify(this.current);
          }, this.scheduleVelocityCheck = () => V.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: r }) => {
            r !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
          }, this.hasAnimated = false, this.prev = this.current = e, this.canTrackVelocity = Su(this.current), this.owner = o2.owner;
        }
        onChange(e) {
          return this.on("change", e);
        }
        on(e, o2) {
          this.events[e] || (this.events[e] = new zt());
          let r = this.events[e].add(o2);
          return e === "change" ? () => {
            r(), V.read(() => {
              this.events.change.getSize() || this.stop();
            });
          } : r;
        }
        clearListeners() {
          for (let e in this.events)
            this.events[e].clear();
        }
        attach(e, o2) {
          this.passiveEffect = e, this.stopPassiveEffect = o2;
        }
        set(e, o2 = true) {
          !o2 || !this.passiveEffect ? this.updateAndNotify(e, o2) : this.passiveEffect(e, this.updateAndNotify);
        }
        setWithVelocity(e, o2, r) {
          this.set(o2), this.prev = e, this.timeDelta = r;
        }
        jump(e) {
          this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
        }
        get() {
          return Re.current && Re.current.push(this), this.current;
        }
        getPrevious() {
          return this.prev;
        }
        getVelocity() {
          return this.canTrackVelocity ? Ae(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
        }
        start(e) {
          return this.stop(), new Promise((o2) => {
            this.hasAnimated = true, this.animation = e(o2), this.events.animationStart && this.events.animationStart.notify();
          }).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
          });
        }
        stop() {
          this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
        }
        isAnimating() {
          return !!this.animation;
        }
        clearAnimation() {
          delete this.animation;
        }
        destroy() {
          this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
        }
      };
      function W(t2, e) {
        return new De(t2, e);
      }
      var yr = (t2) => (e) => e.test(t2);
      var Us = { test: (t2) => t2 === "auto", parse: (t2) => t2 };
      var Nn = [at, T, Z, dt, $i, Wi, Us];
      var Le = (t2) => Nn.find(yr(t2));
      var Vu = [...Nn, j, q];
      var zs = (t2) => Vu.find(yr(t2));
      function Tu(t2, e, o2) {
        t2.hasValue(e) ? t2.getValue(e).set(o2) : t2.addValue(e, W(o2));
      }
      function xr(t2, e) {
        let o2 = jt(t2, e), { transitionEnd: r = {}, transition: n2 = {}, ...s2 } = o2 ? t2.makeTargetAnimatable(o2, false) : {};
        s2 = { ...s2, ...r };
        for (let i2 in s2) {
          let a = os(s2[i2]);
          Tu(t2, i2, a);
        }
      }
      function To(t2, e, o2) {
        var r, n2;
        let s2 = Object.keys(e).filter((a) => !t2.hasValue(a)), i2 = s2.length;
        if (i2)
          for (let a = 0; a < i2; a++) {
            let c = s2[a], l2 = e[c], u2 = null;
            Array.isArray(l2) && (u2 = l2[0]), u2 === null && (u2 = (n2 = (r = o2[c]) !== null && r !== void 0 ? r : t2.readValue(c)) !== null && n2 !== void 0 ? n2 : e[c]), u2 != null && (typeof u2 == "string" && (gr(u2) || hr(u2)) ? u2 = parseFloat(u2) : !zs(u2) && q.test(l2) && (u2 = dr(c, l2)), t2.addValue(c, W(u2, { owner: t2 })), o2[c] === void 0 && (o2[c] = u2), u2 !== null && t2.setBaseTarget(c, u2));
          }
      }
      function bu(t2, e) {
        return e ? (e[t2] || e.default || e).from : void 0;
      }
      function vr(t2, e, o2) {
        let r = {};
        for (let n2 in t2) {
          let s2 = bu(n2, e);
          if (s2 !== void 0)
            r[n2] = s2;
          else {
            let i2 = o2.getValue(n2);
            i2 && (r[n2] = i2.get());
          }
        }
        return r;
      }
      function Pu({ protectedKeys: t2, needsAnimating: e }, o2) {
        let r = t2.hasOwnProperty(o2) && e[o2] !== true;
        return e[o2] = false, r;
      }
      function Cu(t2, e) {
        let o2 = t2.get();
        if (Array.isArray(e)) {
          for (let r = 0; r < e.length; r++)
            if (e[r] !== o2)
              return true;
        } else
          return o2 !== e;
      }
      function ke(t2, e, { delay: o2 = 0, transitionOverride: r, type: n2 } = {}) {
        let { transition: s2 = t2.getDefaultTransition(), transitionEnd: i2, ...a } = t2.makeTargetAnimatable(e), c = t2.getValue("willChange");
        r && (s2 = r);
        let l2 = [], u2 = n2 && t2.animationState && t2.animationState.getState()[n2];
        for (let m2 in a) {
          let f = t2.getValue(m2), p2 = a[m2];
          if (!f || p2 === void 0 || u2 && Pu(u2, m2))
            continue;
          let d = { delay: o2, elapsed: 0, ...Me(s2 || {}, m2) };
          if (window.HandoffAppearAnimations) {
            let S = t2.getProps()[Ze];
            if (S) {
              let x = window.HandoffAppearAnimations(S, m2, f, V);
              x !== null && (d.elapsed = x, d.isHandoff = true);
            }
          }
          let h = !d.isHandoff && !Cu(f, p2);
          if (d.type === "spring" && (f.getVelocity() || d.velocity) && (h = false), f.animation && (h = false), h)
            continue;
          f.start(Ee(m2, f, p2, t2.shouldReduceMotion && z.has(m2) ? { type: false } : d));
          let y = f.animation;
          te(c) && (c.add(m2), y.then(() => c.remove(m2))), l2.push(y);
        }
        return i2 && Promise.all(l2).then(() => {
          i2 && xr(t2, i2);
        }), l2;
      }
      function Sr(t2, e, o2 = {}) {
        let r = jt(t2, e, o2.custom), { transition: n2 = t2.getDefaultTransition() || {} } = r || {};
        o2.transitionOverride && (n2 = o2.transitionOverride);
        let s2 = r ? () => Promise.all(ke(t2, r, o2)) : () => Promise.resolve(), i2 = t2.variantChildren && t2.variantChildren.size ? (c = 0) => {
          let { delayChildren: l2 = 0, staggerChildren: u2, staggerDirection: m2 } = n2;
          return Au(t2, e, l2 + c, u2, m2, o2);
        } : () => Promise.resolve(), { when: a } = n2;
        if (a) {
          let [c, l2] = a === "beforeChildren" ? [s2, i2] : [i2, s2];
          return c().then(() => l2());
        } else
          return Promise.all([s2(), i2(o2.delay)]);
      }
      function Au(t2, e, o2 = 0, r = 0, n2 = 1, s2) {
        let i2 = [], a = (t2.variantChildren.size - 1) * r, c = n2 === 1 ? (l2 = 0) => l2 * r : (l2 = 0) => a - l2 * r;
        return Array.from(t2.variantChildren).sort(wu).forEach((l2, u2) => {
          l2.notify("AnimationStart", e), i2.push(Sr(l2, e, { ...s2, delay: o2 + c(u2) }).then(() => l2.notify("AnimationComplete", e)));
        }), Promise.all(i2);
      }
      function wu(t2, e) {
        return t2.sortNodePosition(e);
      }
      function ee(t2, e, o2 = {}) {
        t2.notify("AnimationStart", e);
        let r;
        if (Array.isArray(e)) {
          let n2 = e.map((s2) => Sr(t2, s2, o2));
          r = Promise.all(n2);
        } else if (typeof e == "string")
          r = Sr(t2, e, o2);
        else {
          let n2 = typeof e == "function" ? jt(t2, e, o2.custom) : e;
          r = Promise.all(ke(t2, n2, o2));
        }
        return r.then(() => t2.notify("AnimationComplete", e));
      }
      var Mu = [...Uo].reverse();
      var Eu = Uo.length;
      function Ru(t2) {
        return (e) => Promise.all(e.map(({ animation: o2, options: r }) => ee(t2, o2, r)));
      }
      function Hs(t2) {
        let e = Ru(t2), o2 = Lu(), r = true, n2 = (c, l2) => {
          let u2 = jt(t2, l2);
          if (u2) {
            let { transition: m2, transitionEnd: f, ...p2 } = u2;
            c = { ...c, ...p2, ...f };
          }
          return c;
        };
        function s2(c) {
          e = c(t2);
        }
        function i2(c, l2) {
          let u2 = t2.getProps(), m2 = t2.getVariantContext(true) || {}, f = [], p2 = /* @__PURE__ */ new Set(), d = {}, h = 1 / 0;
          for (let S = 0; S < Eu; S++) {
            let x = Mu[S], g = o2[x], v = u2[x] !== void 0 ? u2[x] : m2[x], P = bt(v), R = x === l2 ? g.isActive : null;
            R === false && (h = S);
            let D = v === m2[x] && v !== u2[x] && P;
            if (D && r && t2.manuallyAnimateOnMount && (D = false), g.protectedKeys = { ...d }, !g.isActive && R === null || !v && !g.prevProp || It(v) || typeof v == "boolean")
              continue;
            let M = Du(g.prevProp, v) || x === l2 && g.isActive && !D && P || S > h && P, U = false, Dt = Array.isArray(v) ? v : [v], nt = Dt.reduce(n2, {});
            R === false && (nt = {});
            let { prevResolvedValues: st = {} } = g, B = { ...st, ...nt }, xt = (N) => {
              M = true, p2.has(N) && (U = true, p2.delete(N)), g.needsAnimating[N] = true;
            };
            for (let N in B) {
              let ct = nt[N], Lt = st[N];
              if (d.hasOwnProperty(N))
                continue;
              let vt = false;
              Yt(ct) && Yt(Lt) ? vt = !Vn(ct, Lt) : vt = ct !== Lt, vt ? ct !== void 0 ? xt(N) : p2.add(N) : ct !== void 0 && p2.has(N) ? xt(N) : g.protectedKeys[N] = true;
            }
            g.prevProp = v, g.prevResolvedValues = nt, g.isActive && (d = { ...d, ...nt }), r && t2.blockInitialAnimation && (M = false), M && (!D || U) && f.push(...Dt.map((N) => ({ animation: N, options: { type: x, ...c } })));
          }
          if (p2.size) {
            let S = {};
            p2.forEach((x) => {
              let g = t2.getBaseTarget(x);
              g !== void 0 && (S[x] = g);
            }), f.push({ animation: S });
          }
          let y = !!f.length;
          return r && (u2.initial === false || u2.initial === u2.animate) && !t2.manuallyAnimateOnMount && (y = false), r = false, y ? e(f) : Promise.resolve();
        }
        function a(c, l2, u2) {
          var m2;
          if (o2[c].isActive === l2)
            return Promise.resolve();
          (m2 = t2.variantChildren) === null || m2 === void 0 || m2.forEach((p2) => {
            var d;
            return (d = p2.animationState) === null || d === void 0 ? void 0 : d.setActive(c, l2);
          }), o2[c].isActive = l2;
          let f = i2(u2, c);
          for (let p2 in o2)
            o2[p2].protectedKeys = {};
          return f;
        }
        return { animateChanges: i2, setActive: a, setAnimateFunction: s2, getState: () => o2 };
      }
      function Du(t2, e) {
        return typeof e == "string" ? e !== t2 : Array.isArray(e) ? !Vn(e, t2) : false;
      }
      function oe(t2 = false) {
        return { isActive: t2, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} };
      }
      function Lu() {
        return { animate: oe(true), whileInView: oe(), whileHover: oe(), whileTap: oe(), whileDrag: oe(), whileFocus: oe(), exit: oe() };
      }
      var Vr = class extends G {
        constructor(e) {
          super(e), e.animationState || (e.animationState = Hs(e));
        }
        updateAnimationControlsSubscription() {
          let { animate: e } = this.node.getProps();
          this.unmount(), It(e) && (this.unmount = e.subscribe(this.node));
        }
        mount() {
          this.updateAnimationControlsSubscription();
        }
        update() {
          let { animate: e } = this.node.getProps(), { animate: o2 } = this.node.prevProps || {};
          e !== o2 && this.updateAnimationControlsSubscription();
        }
        unmount() {
        }
      };
      var ku = 0;
      var Tr = class extends G {
        constructor() {
          super(...arguments), this.id = ku++;
        }
        update() {
          if (!this.node.presenceContext)
            return;
          let { isPresent: e, onExitComplete: o2, custom: r } = this.node.presenceContext, { isPresent: n2 } = this.node.prevPresenceContext || {};
          if (!this.node.animationState || e === n2)
            return;
          let s2 = this.node.animationState.setActive("exit", !e, { custom: r ?? this.node.getProps().custom });
          o2 && !e && s2.then(() => o2(this.id));
        }
        mount() {
          let { register: e } = this.node.presenceContext || {};
          e && (this.unmount = e(this.id));
        }
        unmount() {
        }
      };
      var bo = { animation: { Feature: Vr }, exit: { Feature: Tr } };
      var zn = (t2, e) => Math.abs(t2 - e);
      function Gn(t2, e) {
        let o2 = zn(t2.x, e.x), r = zn(t2.y, e.y);
        return Math.sqrt(o2 ** 2 + r ** 2);
      }
      var Ie = class {
        constructor(e, o2, { transformPagePoint: r, contextWindow: n2, dragSnapToOrigin: s2 = false } = {}) {
          if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
              return;
            let m2 = Wn(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, p2 = Gn(m2.offset, { x: 0, y: 0 }) >= 3;
            if (!f && !p2)
              return;
            let { point: d } = m2, { timestamp: h } = F;
            this.history.push({ ...d, timestamp: h });
            let { onStart: y, onMove: S } = this.handlers;
            f || (y && y(this.lastMoveEvent, m2), this.startEvent = this.lastMoveEvent), S && S(this.lastMoveEvent, m2);
          }, this.handlePointerMove = (m2, f) => {
            this.lastMoveEvent = m2, this.lastMoveEventInfo = Hn(f, this.transformPagePoint), V.update(this.updatePoint, true);
          }, this.handlePointerUp = (m2, f) => {
            this.end();
            let { onEnd: p2, onSessionEnd: d, resumeAnimation: h } = this.handlers;
            if (this.dragSnapToOrigin && h && h(), !(this.lastMoveEvent && this.lastMoveEventInfo))
              return;
            let y = Wn(m2.type === "pointercancel" ? this.lastMoveEventInfo : Hn(f, this.transformPagePoint), this.history);
            this.startEvent && p2 && p2(m2, y), d && d(m2, y);
          }, !Qo(e))
            return;
          this.dragSnapToOrigin = s2, this.handlers = o2, this.transformPagePoint = r, this.contextWindow = n2 || window;
          let i2 = Zt(e), a = Hn(i2, this.transformPagePoint), { point: c } = a, { timestamp: l2 } = F;
          this.history = [{ ...c, timestamp: l2 }];
          let { onSessionStart: u2 } = o2;
          u2 && u2(e, Wn(a, this.history)), this.removeListeners = Q(J(this.contextWindow, "pointermove", this.handlePointerMove), J(this.contextWindow, "pointerup", this.handlePointerUp), J(this.contextWindow, "pointercancel", this.handlePointerUp));
        }
        updateHandlers(e) {
          this.handlers = e;
        }
        end() {
          this.removeListeners && this.removeListeners(), O(this.updatePoint);
        }
      };
      function Hn(t2, e) {
        return e ? { point: e(t2.point) } : t2;
      }
      function Ws(t2, e) {
        return { x: t2.x - e.x, y: t2.y - e.y };
      }
      function Wn({ point: t2 }, e) {
        return { point: t2, delta: Ws(t2, $s(e)), offset: Ws(t2, Iu(e)), velocity: Ou(e, 0.1) };
      }
      function Iu(t2) {
        return t2[0];
      }
      function $s(t2) {
        return t2[t2.length - 1];
      }
      function Ou(t2, e) {
        if (t2.length < 2)
          return { x: 0, y: 0 };
        let o2 = t2.length - 1, r = null, n2 = $s(t2);
        for (; o2 >= 0 && (r = t2[o2], !(n2.timestamp - r.timestamp > tt(e)));)
          o2--;
        if (!r)
          return { x: 0, y: 0 };
        let s2 = H(n2.timestamp - r.timestamp);
        if (s2 === 0)
          return { x: 0, y: 0 };
        let i2 = { x: (n2.x - r.x) / s2, y: (n2.y - r.y) / s2 };
        return i2.x === 1 / 0 && (i2.x = 0), i2.y === 1 / 0 && (i2.y = 0), i2;
      }
      function $(t2) {
        return t2.max - t2.min;
      }
      function br(t2, e = 0, o2 = 0.01) {
        return Math.abs(t2 - e) <= o2;
      }
      function Ks(t2, e, o2, r = 0.5) {
        t2.origin = r, t2.originPoint = C(e.min, e.max, t2.origin), t2.scale = $(o2) / $(e), (br(t2.scale, 1, 1e-4) || isNaN(t2.scale)) && (t2.scale = 1), t2.translate = C(o2.min, o2.max, t2.origin) - t2.originPoint, (br(t2.translate) || isNaN(t2.translate)) && (t2.translate = 0);
      }
      function Oe(t2, e, o2, r) {
        Ks(t2.x, e.x, o2.x, r ? r.originX : void 0), Ks(t2.y, e.y, o2.y, r ? r.originY : void 0);
      }
      function _s(t2, e, o2) {
        t2.min = o2.min + e.min, t2.max = t2.min + $(e);
      }
      function qs(t2, e, o2) {
        _s(t2.x, e.x, o2.x), _s(t2.y, e.y, o2.y);
      }
      function Ys(t2, e, o2) {
        t2.min = e.min - o2.min, t2.max = t2.min + $(e);
      }
      function Fe(t2, e, o2) {
        Ys(t2.x, e.x, o2.x), Ys(t2.y, e.y, o2.y);
      }
      function ta(t2, { min: e, max: o2 }, r) {
        return e !== void 0 && t2 < e ? t2 = r ? C(e, t2, r.min) : Math.max(t2, e) : o2 !== void 0 && t2 > o2 && (t2 = r ? C(o2, t2, r.max) : Math.min(t2, o2)), t2;
      }
      function Xs(t2, e, o2) {
        return { min: e !== void 0 ? t2.min + e : void 0, max: o2 !== void 0 ? t2.max + o2 - (t2.max - t2.min) : void 0 };
      }
      function ea(t2, { top: e, left: o2, bottom: r, right: n2 }) {
        return { x: Xs(t2.x, o2, n2), y: Xs(t2.y, e, r) };
      }
      function Zs(t2, e) {
        let o2 = e.min - t2.min, r = e.max - t2.max;
        return e.max - e.min < t2.max - t2.min && ([o2, r] = [r, o2]), { min: o2, max: r };
      }
      function oa(t2, e) {
        return { x: Zs(t2.x, e.x), y: Zs(t2.y, e.y) };
      }
      function ra(t2, e) {
        let o2 = 0.5, r = $(t2), n2 = $(e);
        return n2 > r ? o2 = et(e.min, e.max - r, t2.min) : r > n2 && (o2 = et(t2.min, t2.max - n2, e.min)), _(0, 1, o2);
      }
      function na(t2, e) {
        let o2 = {};
        return e.min !== void 0 && (o2.min = e.min - t2.min), e.max !== void 0 && (o2.max = e.max - t2.min), o2;
      }
      var Pr = 0.35;
      function ia(t2 = Pr) {
        return t2 === false ? t2 = 0 : t2 === true && (t2 = Pr), { x: Js(t2, "left", "right"), y: Js(t2, "top", "bottom") };
      }
      function Js(t2, e, o2) {
        return { min: Qs(t2, e), max: Qs(t2, o2) };
      }
      function Qs(t2, e) {
        return typeof t2 == "number" ? t2 : t2[e] || 0;
      }
      var sa = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 });
      var re = () => ({ x: sa(), y: sa() });
      var aa = () => ({ min: 0, max: 0 });
      var k = () => ({ x: aa(), y: aa() });
      function ot(t2) {
        return [t2("x"), t2("y")];
      }
      function Cr({ top: t2, left: e, right: o2, bottom: r }) {
        return { x: { min: e, max: o2 }, y: { min: t2, max: r } };
      }
      function ca({ x: t2, y: e }) {
        return { top: e.min, right: t2.max, bottom: e.max, left: t2.min };
      }
      function la(t2, e) {
        if (!e)
          return t2;
        let o2 = e({ x: t2.left, y: t2.top }), r = e({ x: t2.right, y: t2.bottom });
        return { top: o2.y, left: o2.x, bottom: r.y, right: r.x };
      }
      function $n(t2) {
        return t2 === void 0 || t2 === 1;
      }
      function Ar({ scale: t2, scaleX: e, scaleY: o2 }) {
        return !$n(t2) || !$n(e) || !$n(o2);
      }
      function wt(t2) {
        return Ar(t2) || Kn(t2) || t2.z || t2.rotate || t2.rotateX || t2.rotateY;
      }
      function Kn(t2) {
        return ua(t2.x) || ua(t2.y);
      }
      function ua(t2) {
        return t2 && t2 !== "0%";
      }
      function Po(t2, e, o2) {
        let r = t2 - o2, n2 = e * r;
        return o2 + n2;
      }
      function ma(t2, e, o2, r, n2) {
        return n2 !== void 0 && (t2 = Po(t2, n2, r)), Po(t2, o2, r) + e;
      }
      function _n(t2, e = 0, o2 = 1, r, n2) {
        t2.min = ma(t2.min, e, o2, r, n2), t2.max = ma(t2.max, e, o2, r, n2);
      }
      function Yn(t2, { x: e, y: o2 }) {
        _n(t2.x, e.translate, e.scale, e.originPoint), _n(t2.y, o2.translate, o2.scale, o2.originPoint);
      }
      function da(t2, e, o2, r = false) {
        let n2 = o2.length;
        if (!n2)
          return;
        e.x = e.y = 1;
        let s2, i2;
        for (let a = 0; a < n2; a++) {
          s2 = o2[a], i2 = s2.projectionDelta;
          let c = s2.instance;
          c && c.style && c.style.display === "contents" || (r && s2.options.layoutScroll && s2.scroll && s2 !== s2.root && ne(t2, { x: -s2.scroll.offset.x, y: -s2.scroll.offset.y }), i2 && (e.x *= i2.x.scale, e.y *= i2.y.scale, Yn(t2, i2)), r && wt(s2.latestValues) && ne(t2, s2.latestValues));
        }
        e.x = fa(e.x), e.y = fa(e.y);
      }
      function fa(t2) {
        return Number.isInteger(t2) || t2 > 1.0000000000001 || t2 < 0.999999999999 ? t2 : 1;
      }
      function yt(t2, e) {
        t2.min = t2.min + e, t2.max = t2.max + e;
      }
      function pa(t2, e, [o2, r, n2]) {
        let s2 = e[n2] !== void 0 ? e[n2] : 0.5, i2 = C(t2.min, t2.max, s2);
        _n(t2, e[o2], e[r], i2, e.scale);
      }
      var Fu = ["x", "scaleX", "originX"];
      var Bu = ["y", "scaleY", "originY"];
      function ne(t2, e) {
        pa(t2.x, e, Fu), pa(t2.y, e, Bu);
      }
      function qn(t2, e) {
        return Cr(la(t2.getBoundingClientRect(), e));
      }
      function ha(t2, e, o2) {
        let r = qn(t2, o2), { scroll: n2 } = e;
        return n2 && (yt(r.x, n2.offset.x), yt(r.y, n2.offset.y)), r;
      }
      var wr = ({ current: t2 }) => t2 ? t2.ownerDocument.defaultView : null;
      var ju = /* @__PURE__ */ new WeakMap();
      var Er = class {
        constructor(e) {
          this.openGlobalLock = null, this.isDragging = false, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = false, this.hasMutatedConstraints = false, this.elastic = k(), this.visualElement = e;
        }
        start(e, { snapToCursor: o2 = false } = {}) {
          let { presenceContext: r } = this.visualElement;
          if (r && r.isPresent === false)
            return;
          let n2 = (u2) => {
            let { dragSnapToOrigin: m2 } = this.getProps();
            m2 ? this.pauseAnimation() : this.stopAnimation(), o2 && this.snapToCursor(Zt(u2, "page").point);
          }, s2 = (u2, m2) => {
            let { drag: f, dragPropagation: p2, onDragStart: d } = this.getProps();
            if (f && !p2 && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = gn(f), !this.openGlobalLock))
              return;
            this.isDragging = true, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = true, this.visualElement.projection.target = void 0), ot((y) => {
              let S = this.getAxisMotionValue(y).get() || 0;
              if (Z.test(S)) {
                let { projection: x } = this.visualElement;
                if (x && x.layout) {
                  let g = x.layout.layoutBox[y];
                  g && (S = $(g) * (parseFloat(S) / 100));
                }
              }
              this.originPoint[y] = S;
            }), d && V.update(() => d(u2, m2), false, true);
            let { animationState: h } = this.visualElement;
            h && h.setActive("whileDrag", true);
          }, i2 = (u2, m2) => {
            let { dragPropagation: f, dragDirectionLock: p2, onDirectionLock: d, onDrag: h } = this.getProps();
            if (!f && !this.openGlobalLock)
              return;
            let { offset: y } = m2;
            if (p2 && this.currentDirection === null) {
              this.currentDirection = Nu(y), this.currentDirection !== null && d && d(this.currentDirection);
              return;
            }
            this.updateAxis("x", m2.point, y), this.updateAxis("y", m2.point, y), this.visualElement.render(), h && h(u2, m2);
          }, a = (u2, m2) => this.stop(u2, m2), c = () => ot((u2) => {
            var m2;
            return this.getAnimationState(u2) === "paused" && ((m2 = this.getAxisMotionValue(u2).animation) === null || m2 === void 0 ? void 0 : m2.play());
          }), { dragSnapToOrigin: l2 } = this.getProps();
          this.panSession = new Ie(e, { onSessionStart: n2, onStart: s2, onMove: i2, onSessionEnd: a, resumeAnimation: c }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: l2, contextWindow: wr(this.visualElement) });
        }
        stop(e, o2) {
          let r = this.isDragging;
          if (this.cancel(), !r)
            return;
          let { velocity: n2 } = o2;
          this.startAnimation(n2);
          let { onDragEnd: s2 } = this.getProps();
          s2 && V.update(() => s2(e, o2));
        }
        cancel() {
          this.isDragging = false;
          let { projection: e, animationState: o2 } = this.visualElement;
          e && (e.isAnimationBlocked = false), this.panSession && this.panSession.end(), this.panSession = void 0;
          let { dragPropagation: r } = this.getProps();
          !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), o2 && o2.setActive("whileDrag", false);
        }
        updateAxis(e, o2, r) {
          let { drag: n2 } = this.getProps();
          if (!r || !Mr(e, n2, this.currentDirection))
            return;
          let s2 = this.getAxisMotionValue(e), i2 = this.originPoint[e] + r[e];
          this.constraints && this.constraints[e] && (i2 = ta(i2, this.constraints[e], this.elastic[e])), s2.set(i2);
        }
        resolveConstraints() {
          var e;
          let { dragConstraints: o2, dragElastic: r } = this.getProps(), n2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s2 = this.constraints;
          o2 && Tt(o2) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : o2 && n2 ? this.constraints = ea(n2.layoutBox, o2) : this.constraints = false, this.elastic = ia(r), s2 !== this.constraints && n2 && this.constraints && !this.hasMutatedConstraints && ot((i2) => {
            this.getAxisMotionValue(i2) && (this.constraints[i2] = na(n2.layoutBox[i2], this.constraints[i2]));
          });
        }
        resolveRefConstraints() {
          let { dragConstraints: e, onMeasureDragConstraints: o2 } = this.getProps();
          if (!e || !Tt(e))
            return false;
          let r = e.current;
          E(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
          let { projection: n2 } = this.visualElement;
          if (!n2 || !n2.layout)
            return false;
          let s2 = ha(r, n2.root, this.visualElement.getTransformPagePoint()), i2 = oa(n2.layout.layoutBox, s2);
          if (o2) {
            let a = o2(ca(i2));
            this.hasMutatedConstraints = !!a, a && (i2 = Cr(a));
          }
          return i2;
        }
        startAnimation(e) {
          let { drag: o2, dragMomentum: r, dragElastic: n2, dragTransition: s2, dragSnapToOrigin: i2, onDragTransitionEnd: a } = this.getProps(), c = this.constraints || {}, l2 = ot((u2) => {
            if (!Mr(u2, o2, this.currentDirection))
              return;
            let m2 = c && c[u2] || {};
            i2 && (m2 = { min: 0, max: 0 });
            let f = n2 ? 200 : 1e6, p2 = n2 ? 40 : 1e7, d = { type: "inertia", velocity: r ? e[u2] : 0, bounceStiffness: f, bounceDamping: p2, timeConstant: 750, restDelta: 1, restSpeed: 10, ...s2, ...m2 };
            return this.startAxisValueAnimation(u2, d);
          });
          return Promise.all(l2).then(a);
        }
        startAxisValueAnimation(e, o2) {
          let r = this.getAxisMotionValue(e);
          return r.start(Ee(e, r, 0, o2));
        }
        stopAnimation() {
          ot((e) => this.getAxisMotionValue(e).stop());
        }
        pauseAnimation() {
          ot((e) => {
            var o2;
            return (o2 = this.getAxisMotionValue(e).animation) === null || o2 === void 0 ? void 0 : o2.pause();
          });
        }
        getAnimationState(e) {
          var o2;
          return (o2 = this.getAxisMotionValue(e).animation) === null || o2 === void 0 ? void 0 : o2.state;
        }
        getAxisMotionValue(e) {
          let o2 = "_drag" + e.toUpperCase(), r = this.visualElement.getProps(), n2 = r[o2];
          return n2 || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0);
        }
        snapToCursor(e) {
          ot((o2) => {
            let { drag: r } = this.getProps();
            if (!Mr(o2, r, this.currentDirection))
              return;
            let { projection: n2 } = this.visualElement, s2 = this.getAxisMotionValue(o2);
            if (n2 && n2.layout) {
              let { min: i2, max: a } = n2.layout.layoutBox[o2];
              s2.set(e[o2] - C(i2, a, 0.5));
            }
          });
        }
        scalePositionWithinConstraints() {
          if (!this.visualElement.current)
            return;
          let { drag: e, dragConstraints: o2 } = this.getProps(), { projection: r } = this.visualElement;
          if (!Tt(o2) || !r || !this.constraints)
            return;
          this.stopAnimation();
          let n2 = { x: 0, y: 0 };
          ot((i2) => {
            let a = this.getAxisMotionValue(i2);
            if (a) {
              let c = a.get();
              n2[i2] = ra({ min: c, max: c }, this.constraints[i2]);
            }
          });
          let { transformTemplate: s2 } = this.visualElement.getProps();
          this.visualElement.current.style.transform = s2 ? s2({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), ot((i2) => {
            if (!Mr(i2, e, null))
              return;
            let a = this.getAxisMotionValue(i2), { min: c, max: l2 } = this.constraints[i2];
            a.set(C(c, l2, n2[i2]));
          });
        }
        addListeners() {
          if (!this.visualElement.current)
            return;
          ju.set(this.visualElement, this);
          let e = this.visualElement.current, o2 = J(e, "pointerdown", (c) => {
            let { drag: l2, dragListener: u2 = true } = this.getProps();
            l2 && u2 && this.start(c);
          }), r = () => {
            let { dragConstraints: c } = this.getProps();
            Tt(c) && (this.constraints = this.resolveRefConstraints());
          }, { projection: n2 } = this.visualElement, s2 = n2.addEventListener("measure", r);
          n2 && !n2.layout && (n2.root && n2.root.updateScroll(), n2.updateLayout()), r();
          let i2 = Y(window, "resize", () => this.scalePositionWithinConstraints()), a = n2.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: l2 }) => {
            this.isDragging && l2 && (ot((u2) => {
              let m2 = this.getAxisMotionValue(u2);
              m2 && (this.originPoint[u2] += c[u2].translate, m2.set(m2.get() + c[u2].translate));
            }), this.visualElement.render());
          });
          return () => {
            i2(), o2(), s2(), a && a();
          };
        }
        getProps() {
          let e = this.visualElement.getProps(), { drag: o2 = false, dragDirectionLock: r = false, dragPropagation: n2 = false, dragConstraints: s2 = false, dragElastic: i2 = Pr, dragMomentum: a = true } = e;
          return { ...e, drag: o2, dragDirectionLock: r, dragPropagation: n2, dragConstraints: s2, dragElastic: i2, dragMomentum: a };
        }
      };
      function Mr(t2, e, o2) {
        return (e === true || e === t2) && (o2 === null || o2 === t2);
      }
      function Nu(t2, e = 10) {
        let o2 = null;
        return Math.abs(t2.y) > e ? o2 = "y" : Math.abs(t2.x) > e && (o2 = "x"), o2;
      }
      var Rr = class extends G {
        constructor(e) {
          super(e), this.removeGroupControls = w, this.removeListeners = w, this.controls = new Er(e);
        }
        mount() {
          let { dragControls: e } = this.node.getProps();
          e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || w;
        }
        unmount() {
          this.removeGroupControls(), this.removeListeners();
        }
      };
      var ga = (t2) => (e, o2) => {
        t2 && V.update(() => t2(e, o2));
      };
      var Dr = class extends G {
        constructor() {
          super(...arguments), this.removePointerDownListener = w;
        }
        onPointerDown(e) {
          this.session = new Ie(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: wr(this.node) });
        }
        createPanHandlers() {
          let { onPanSessionStart: e, onPanStart: o2, onPan: r, onPanEnd: n2 } = this.node.getProps();
          return {
            onSessionStart: ga(e), onStart: ga(o2), onMove: r, onEnd: (s2, i2) => {
              delete this.session, n2 && V.update(() => n2(s2, i2));
            }
          };
        }
        mount() {
          this.removePointerDownListener = J(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
        }
        update() {
          this.session && this.session.updateHandlers(this.createPanHandlers());
        }
        unmount() {
          this.removePointerDownListener(), this.session && this.session.end();
        }
      };
      function Xn() {
        let t2 = (0, import_react18.useContext)(ft);
        if (t2 === null)
          return [true, null];
        let { isPresent: e, onExitComplete: o2, register: r } = t2, n2 = (0, import_react18.useId)();
        return (0, import_react18.useEffect)(() => r(n2), []), !e && o2 ? [false, () => o2 && o2(n2)] : [true];
      }
      var Be = { hasAnimatedSinceResize: true, hasEverUpdated: false };
      function xa(t2, e) {
        return e.max === e.min ? 0 : t2 / (e.max - e.min) * 100;
      }
      var je = {
        correct: (t2, e) => {
          if (!e.target)
            return t2;
          if (typeof t2 == "string")
            if (T.test(t2))
              t2 = parseFloat(t2);
            else
              return t2;
          let o2 = xa(t2, e.target.x), r = xa(t2, e.target.y);
          return `${o2}% ${r}%`;
        }
      };
      var va = {
        correct: (t2, { treeScale: e, projectionDelta: o2 }) => {
          let r = t2, n2 = q.parse(t2);
          if (n2.length > 5)
            return r;
          let s2 = q.createTransformer(t2), i2 = typeof n2[0] != "number" ? 1 : 0, a = o2.x.scale * e.x, c = o2.y.scale * e.y;
          n2[0 + i2] /= a, n2[1 + i2] /= c;
          let l2 = C(a, c, 0.5);
          return typeof n2[2 + i2] == "number" && (n2[2 + i2] /= l2), typeof n2[3 + i2] == "number" && (n2[3 + i2] /= l2), s2(n2);
        }
      };
      var Zn = class extends import_react17.default.Component {
        componentDidMount() {
          let { visualElement: e, layoutGroup: o2, switchLayoutGroup: r, layoutId: n2 } = this.props, { projection: s2 } = e;
          nn(Wu), s2 && (o2.group && o2.group.add(s2), r && r.register && n2 && r.register(s2), s2.root.didUpdate(), s2.addEventListener("animationComplete", () => {
            this.safeToRemove();
          }), s2.setOptions({ ...s2.options, onExitComplete: () => this.safeToRemove() })), Be.hasEverUpdated = true;
        }
        getSnapshotBeforeUpdate(e) {
          let { layoutDependency: o2, visualElement: r, drag: n2, isPresent: s2 } = this.props, i2 = r.projection;
          return i2 && (i2.isPresent = s2, n2 || e.layoutDependency !== o2 || o2 === void 0 ? i2.willUpdate() : this.safeToRemove(), e.isPresent !== s2 && (s2 ? i2.promote() : i2.relegate() || V.postRender(() => {
            let a = i2.getStack();
            (!a || !a.members.length) && this.safeToRemove();
          }))), null;
        }
        componentDidUpdate() {
          let { projection: e } = this.props.visualElement;
          e && (e.root.didUpdate(), queueMicrotask(() => {
            !e.currentAnimation && e.isLead() && this.safeToRemove();
          }));
        }
        componentWillUnmount() {
          let { visualElement: e, layoutGroup: o2, switchLayoutGroup: r } = this.props, { projection: n2 } = e;
          n2 && (n2.scheduleCheckAfterUnmount(), o2 && o2.group && o2.group.remove(n2), r && r.deregister && r.deregister(n2));
        }
        safeToRemove() {
          let { safeToRemove: e } = this.props;
          e && e();
        }
        render() {
          return null;
        }
      };
      function Lr(t2) {
        let [e, o2] = Xn(), r = (0, import_react17.useContext)(pt);
        return import_react17.default.createElement(Zn, { ...t2, layoutGroup: r, switchLayoutGroup: (0, import_react17.useContext)(to), isPresent: e, safeToRemove: o2 });
      }
      var Wu = { borderRadius: { ...je, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: je, borderTopRightRadius: je, borderBottomLeftRadius: je, borderBottomRightRadius: je, boxShadow: va };
      var Ca = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
      var $u = Ca.length;
      var Ta = (t2) => typeof t2 == "string" ? parseFloat(t2) : t2;
      var ba = (t2) => typeof t2 == "number" || T.test(t2);
      function Aa(t2, e, o2, r, n2, s2) {
        n2 ? (t2.opacity = C(0, o2.opacity !== void 0 ? o2.opacity : 1, Ku(r)), t2.opacityExit = C(e.opacity !== void 0 ? e.opacity : 1, 0, _u(r))) : s2 && (t2.opacity = C(e.opacity !== void 0 ? e.opacity : 1, o2.opacity !== void 0 ? o2.opacity : 1, r));
        for (let i2 = 0; i2 < $u; i2++) {
          let a = `border${Ca[i2]}Radius`, c = Pa(e, a), l2 = Pa(o2, a);
          if (c === void 0 && l2 === void 0)
            continue;
          c || (c = 0), l2 || (l2 = 0), c === 0 || l2 === 0 || ba(c) === ba(l2) ? (t2[a] = Math.max(C(Ta(c), Ta(l2), r), 0), (Z.test(l2) || Z.test(c)) && (t2[a] += "%")) : t2[a] = l2;
        }
        (e.rotate || o2.rotate) && (t2.rotate = C(e.rotate || 0, o2.rotate || 0, r));
      }
      function Pa(t2, e) {
        return t2[e] !== void 0 ? t2[e] : t2.borderRadius;
      }
      var Ku = wa(0, 0.5, po);
      var _u = wa(0.5, 0.95, w);
      function wa(t2, e, o2) {
        return (r) => r < t2 ? 0 : r > e ? 1 : o2(et(t2, e, r));
      }
      function Ma(t2, e) {
        t2.min = e.min, t2.max = e.max;
      }
      function it(t2, e) {
        Ma(t2.x, e.x), Ma(t2.y, e.y);
      }
      function Ea(t2, e, o2, r, n2) {
        return t2 -= e, t2 = Po(t2, 1 / o2, r), n2 !== void 0 && (t2 = Po(t2, 1 / n2, r)), t2;
      }
      function Yu(t2, e = 0, o2 = 1, r = 0.5, n2, s2 = t2, i2 = t2) {
        if (Z.test(e) && (e = parseFloat(e), e = C(i2.min, i2.max, e / 100) - i2.min), typeof e != "number")
          return;
        let a = C(s2.min, s2.max, r);
        t2 === s2 && (a -= e), t2.min = Ea(t2.min, e, o2, a, n2), t2.max = Ea(t2.max, e, o2, a, n2);
      }
      function Ra(t2, e, [o2, r, n2], s2, i2) {
        Yu(t2, e[o2], e[r], e[n2], e.scale, s2, i2);
      }
      var qu = ["x", "scaleX", "originX"];
      var Xu = ["y", "scaleY", "originY"];
      function Jn(t2, e, o2, r) {
        Ra(t2.x, e, qu, o2 ? o2.x : void 0, r ? r.x : void 0), Ra(t2.y, e, Xu, o2 ? o2.y : void 0, r ? r.y : void 0);
      }
      function Da(t2) {
        return t2.translate === 0 && t2.scale === 1;
      }
      function Qn(t2) {
        return Da(t2.x) && Da(t2.y);
      }
      function La(t2, e) {
        return t2.x.min === e.x.min && t2.x.max === e.x.max && t2.y.min === e.y.min && t2.y.max === e.y.max;
      }
      function ti(t2, e) {
        return Math.round(t2.x.min) === Math.round(e.x.min) && Math.round(t2.x.max) === Math.round(e.x.max) && Math.round(t2.y.min) === Math.round(e.y.min) && Math.round(t2.y.max) === Math.round(e.y.max);
      }
      function ei(t2) {
        return $(t2.x) / $(t2.y);
      }
      var kr = class {
        constructor() {
          this.members = [];
        }
        add(e) {
          Ut(this.members, e), e.scheduleRender();
        }
        remove(e) {
          if (mt(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
            let o2 = this.members[this.members.length - 1];
            o2 && this.promote(o2);
          }
        }
        relegate(e) {
          let o2 = this.members.findIndex((n2) => e === n2);
          if (o2 === 0)
            return false;
          let r;
          for (let n2 = o2; n2 >= 0; n2--) {
            let s2 = this.members[n2];
            if (s2.isPresent !== false) {
              r = s2;
              break;
            }
          }
          return r ? (this.promote(r), true) : false;
        }
        promote(e, o2) {
          let r = this.lead;
          if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) {
            r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, o2 && (e.resumeFrom.preserveOpacity = true), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = true);
            let { crossfade: n2 } = e.options;
            n2 === false && r.hide();
          }
        }
        exitAnimationComplete() {
          this.members.forEach((e) => {
            let { options: o2, resumingFrom: r } = e;
            o2.onExitComplete && o2.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
          });
        }
        scheduleRender() {
          this.members.forEach((e) => {
            e.instance && e.scheduleRender(false);
          });
        }
        removeLeadSnapshot() {
          this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
        }
      };
      function oi(t2, e, o2) {
        let r = "", n2 = t2.x.translate / e.x, s2 = t2.y.translate / e.y;
        if ((n2 || s2) && (r = `translate3d(${n2}px, ${s2}px, 0) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `), o2) {
          let { rotate: c, rotateX: l2, rotateY: u2 } = o2;
          c && (r += `rotate(${c}deg) `), l2 && (r += `rotateX(${l2}deg) `), u2 && (r += `rotateY(${u2}deg) `);
        }
        let i2 = t2.x.scale * e.x, a = t2.y.scale * e.y;
        return (i2 !== 1 || a !== 1) && (r += `scale(${i2}, ${a})`), r || "none";
      }
      var ka = (t2, e) => t2.depth - e.depth;
      var Co = class {
        constructor() {
          this.children = [], this.isDirty = false;
        }
        add(e) {
          Ut(this.children, e), this.isDirty = true;
        }
        remove(e) {
          mt(this.children, e), this.isDirty = true;
        }
        forEach(e) {
          this.isDirty && this.children.sort(ka), this.isDirty = false, this.children.forEach(e);
        }
      };
      function ri(t2, e) {
        let o2 = performance.now(), r = ({ timestamp: n2 }) => {
          let s2 = n2 - o2;
          s2 >= e && (O(r), t2(s2 - e));
        };
        return V.read(r, true), () => O(r);
      }
      function Ia(t2) {
        window.MotionDebug && window.MotionDebug.record(t2);
      }
      function Ir(t2) {
        return t2 instanceof SVGElement && t2.tagName !== "svg";
      }
      function Ao(t2, e, o2) {
        let r = A(t2) ? t2 : W(t2);
        return r.start(Ee("", r, e, o2)), r.animation;
      }
      var Oa = ["", "X", "Y", "Z"];
      var Zu = { visibility: "hidden" };
      var Fa = 1e3;
      var Ju = 0;
      var ie = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 };
      function Or({ attachResizeListener: t2, defaultParent: e, measureScroll: o2, checkIsScrollRoot: r, resetTransform: n2 }) {
        return class {
          constructor(i2 = {}, a = e?.()) {
            this.id = Ju++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = false, this.isAnimationBlocked = false, this.isLayoutDirty = false, this.isProjectionDirty = false, this.isSharedProjectionDirty = false, this.isTransformDirty = false, this.updateManuallyBlocked = false, this.updateBlockedByResize = false, this.isUpdating = false, this.isSVG = false, this.needsReset = false, this.shouldResetTransform = false, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = false, this.updateScheduled = false, this.projectionUpdateScheduled = false, this.checkUpdateFailed = () => {
              this.isUpdating && (this.isUpdating = false, this.clearAllSnapshots());
            }, this.updateProjection = () => {
              this.projectionUpdateScheduled = false, ie.totalNodes = ie.resolvedTargetDeltas = ie.recalculatedProjection = 0, this.nodes.forEach(em), this.nodes.forEach(sm), this.nodes.forEach(am), this.nodes.forEach(om), Ia(ie);
            }, this.hasProjected = false, this.isVisible = true, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = i2, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
            for (let c = 0; c < this.path.length; c++)
              this.path[c].shouldResetTransform = true;
            this.root === this && (this.nodes = new Co());
          }
          addEventListener(i2, a) {
            return this.eventHandlers.has(i2) || this.eventHandlers.set(i2, new zt()), this.eventHandlers.get(i2).add(a);
          }
          notifyListeners(i2, ...a) {
            let c = this.eventHandlers.get(i2);
            c && c.notify(...a);
          }
          hasListeners(i2) {
            return this.eventHandlers.has(i2);
          }
          mount(i2, a = this.root.hasTreeAnimated) {
            if (this.instance)
              return;
            this.isSVG = Ir(i2), this.instance = i2;
            let { layoutId: c, layout: l2, visualElement: u2 } = this.options;
            if (u2 && !u2.current && u2.mount(i2), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (l2 || c) && (this.isLayoutDirty = true), t2) {
              let m2, f = () => this.root.updateBlockedByResize = false;
              t2(i2, () => {
                this.root.updateBlockedByResize = true, m2 && m2(), m2 = ri(f, 250), Be.hasAnimatedSinceResize && (Be.hasAnimatedSinceResize = false, this.nodes.forEach(ja));
              });
            }
            c && this.root.registerSharedNode(c, this), this.options.animate !== false && u2 && (c || l2) && this.addEventListener("didUpdate", ({ delta: m2, hasLayoutChanged: f, hasRelativeTargetChanged: p2, layout: d }) => {
              if (this.isTreeAnimationBlocked()) {
                this.target = void 0, this.relativeTarget = void 0;
                return;
              }
              let h = this.options.transition || u2.getDefaultTransition() || fm, { onLayoutAnimationStart: y, onLayoutAnimationComplete: S } = u2.getProps(), x = !this.targetLayout || !ti(this.targetLayout, d) || p2, g = !f && p2;
              if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || g || f && (x || !this.currentAnimation)) {
                this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(m2, g);
                let v = { ...Me(h, "layout"), onPlay: y, onComplete: S };
                (u2.shouldReduceMotion || this.options.layoutRoot) && (v.delay = 0, v.type = false), this.startAnimation(v);
              } else
                f || ja(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
              this.targetLayout = d;
            });
          }
          unmount() {
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
            let i2 = this.getStack();
            i2 && i2.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, O(this.updateProjection);
          }
          blockUpdate() {
            this.updateManuallyBlocked = true;
          }
          unblockUpdate() {
            this.updateManuallyBlocked = false;
          }
          isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize;
          }
          isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
          }
          startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = true, this.nodes && this.nodes.forEach(cm), this.animationId++);
          }
          getTransformTemplate() {
            let { visualElement: i2 } = this.options;
            return i2 && i2.getProps().transformTemplate;
          }
          willUpdate(i2 = true) {
            if (this.root.hasTreeAnimated = true, this.root.isUpdateBlocked()) {
              this.options.onExitComplete && this.options.onExitComplete();
              return;
            }
            if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
              return;
            this.isLayoutDirty = true;
            for (let u2 = 0; u2 < this.path.length; u2++) {
              let m2 = this.path[u2];
              m2.shouldResetTransform = true, m2.updateScroll("snapshot"), m2.options.layoutRoot && m2.willUpdate(false);
            }
            let { layoutId: a, layout: c } = this.options;
            if (a === void 0 && !c)
              return;
            let l2 = this.getTransformTemplate();
            this.prevTransformTemplateValue = l2 ? l2(this.latestValues, "") : void 0, this.updateSnapshot(), i2 && this.notifyListeners("willUpdate");
          }
          update() {
            if (this.updateScheduled = false, this.isUpdateBlocked()) {
              this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Ba);
              return;
            }
            this.isUpdating || this.nodes.forEach(nm), this.isUpdating = false, this.nodes.forEach(im), this.nodes.forEach(Qu), this.nodes.forEach(tm), this.clearAllSnapshots();
            let a = performance.now();
            F.delta = _(0, 1e3 / 60, a - F.timestamp), F.timestamp = a, F.isProcessing = true, no.update.process(F), no.preRender.process(F), no.render.process(F), F.isProcessing = false;
          }
          didUpdate() {
            this.updateScheduled || (this.updateScheduled = true, queueMicrotask(() => this.update()));
          }
          clearAllSnapshots() {
            this.nodes.forEach(rm), this.sharedNodes.forEach(lm);
          }
          scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = true, V.preRender(this.updateProjection, false, true));
          }
          scheduleCheckAfterUnmount() {
            V.postRender(() => {
              this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
            });
          }
          updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure());
          }
          updateLayout() {
            if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
              return;
            if (this.resumeFrom && !this.resumeFrom.instance)
              for (let c = 0; c < this.path.length; c++)
                this.path[c].updateScroll();
            let i2 = this.layout;
            this.layout = this.measure(false), this.layoutCorrected = k(), this.isLayoutDirty = false, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
            let { visualElement: a } = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, i2 ? i2.layoutBox : void 0);
          }
          updateScroll(i2 = "measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === i2 && (a = false), a && (this.scroll = { animationId: this.root.animationId, phase: i2, isRoot: r(this.instance), offset: o2(this.instance) });
          }
          resetTransform() {
            if (!n2)
              return;
            let i2 = this.isLayoutDirty || this.shouldResetTransform, a = this.projectionDelta && !Qn(this.projectionDelta), c = this.getTransformTemplate(), l2 = c ? c(this.latestValues, "") : void 0, u2 = l2 !== this.prevTransformTemplateValue;
            i2 && (a || wt(this.latestValues) || u2) && (n2(this.instance, l2), this.shouldResetTransform = false, this.scheduleRender());
          }
          measure(i2 = true) {
            let a = this.measurePageBox(), c = this.removeElementScroll(a);
            return i2 && (c = this.removeTransform(c)), pm(c), { animationId: this.root.animationId, measuredBox: a, layoutBox: c, latestValues: {}, source: this.id };
          }
          measurePageBox() {
            let { visualElement: i2 } = this.options;
            if (!i2)
              return k();
            let a = i2.measureViewportBox(), { scroll: c } = this.root;
            return c && (yt(a.x, c.offset.x), yt(a.y, c.offset.y)), a;
          }
          removeElementScroll(i2) {
            let a = k();
            it(a, i2);
            for (let c = 0; c < this.path.length; c++) {
              let l2 = this.path[c], { scroll: u2, options: m2 } = l2;
              if (l2 !== this.root && u2 && m2.layoutScroll) {
                if (u2.isRoot) {
                  it(a, i2);
                  let { scroll: f } = this.root;
                  f && (yt(a.x, -f.offset.x), yt(a.y, -f.offset.y));
                }
                yt(a.x, u2.offset.x), yt(a.y, u2.offset.y);
              }
            }
            return a;
          }
          applyTransform(i2, a = false) {
            let c = k();
            it(c, i2);
            for (let l2 = 0; l2 < this.path.length; l2++) {
              let u2 = this.path[l2];
              !a && u2.options.layoutScroll && u2.scroll && u2 !== u2.root && ne(c, { x: -u2.scroll.offset.x, y: -u2.scroll.offset.y }), wt(u2.latestValues) && ne(c, u2.latestValues);
            }
            return wt(this.latestValues) && ne(c, this.latestValues), c;
          }
          removeTransform(i2) {
            let a = k();
            it(a, i2);
            for (let c = 0; c < this.path.length; c++) {
              let l2 = this.path[c];
              if (!l2.instance || !wt(l2.latestValues))
                continue;
              Ar(l2.latestValues) && l2.updateSnapshot();
              let u2 = k(), m2 = l2.measurePageBox();
              it(u2, m2), Jn(a, l2.latestValues, l2.snapshot ? l2.snapshot.layoutBox : void 0, u2);
            }
            return wt(this.latestValues) && Jn(a, this.latestValues), a;
          }
          setTargetDelta(i2) {
            this.targetDelta = i2, this.root.scheduleUpdateProjection(), this.isProjectionDirty = true;
          }
          setOptions(i2) {
            this.options = { ...this.options, ...i2, crossfade: i2.crossfade !== void 0 ? i2.crossfade : true };
          }
          clearMeasurements() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = false;
          }
          forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== F.timestamp && this.relativeParent.resolveTargetDelta(true);
          }
          resolveTargetDelta(i2 = false) {
            var a;
            let c = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = c.isSharedProjectionDirty);
            let l2 = !!this.resumingFrom || this !== c;
            if (!(i2 || l2 && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget))
              return;
            let { layout: m2, layoutId: f } = this.options;
            if (!(!this.layout || !(m2 || f))) {
              if (this.resolvedRelativeTargetAt = F.timestamp, !this.targetDelta && !this.relativeTarget) {
                let p2 = this.getClosestProjectingParent();
                p2 && p2.layout && this.animationProgress !== 1 ? (this.relativeParent = p2, this.forceRelativeParentToResolveTarget(), this.relativeTarget = k(), this.relativeTargetOrigin = k(), Fe(this.relativeTargetOrigin, this.layout.layoutBox, p2.layout.layoutBox), it(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
              }
              if (!(!this.relativeTarget && !this.targetDelta)) {
                if (this.target || (this.target = k(), this.targetWithTransforms = k()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), qs(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : it(this.target, this.layout.layoutBox), Yn(this.target, this.targetDelta)) : it(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                  this.attemptToResolveRelativeTarget = false;
                  let p2 = this.getClosestProjectingParent();
                  p2 && !!p2.resumingFrom == !!this.resumingFrom && !p2.options.layoutScroll && p2.target && this.animationProgress !== 1 ? (this.relativeParent = p2, this.forceRelativeParentToResolveTarget(), this.relativeTarget = k(), this.relativeTargetOrigin = k(), Fe(this.relativeTargetOrigin, this.target, p2.target), it(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
                }
                ie.resolvedTargetDeltas++;
              }
            }
          }
          getClosestProjectingParent() {
            if (!(!this.parent || Ar(this.parent.latestValues) || Kn(this.parent.latestValues)))
              return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
          }
          isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
          }
          calcProjection() {
            var i2;
            let a = this.getLead(), c = !!this.resumingFrom || this !== a, l2 = true;
            if ((this.isProjectionDirty || !((i2 = this.parent) === null || i2 === void 0) && i2.isProjectionDirty) && (l2 = false), c && (this.isSharedProjectionDirty || this.isTransformDirty) && (l2 = false), this.resolvedRelativeTargetAt === F.timestamp && (l2 = false), l2)
              return;
            let { layout: u2, layoutId: m2 } = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u2 || m2))
              return;
            it(this.layoutCorrected, this.layout.layoutBox);
            let f = this.treeScale.x, p2 = this.treeScale.y;
            da(this.layoutCorrected, this.treeScale, this.path, c), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox);
            let { target: d } = a;
            if (!d) {
              this.projectionTransform && (this.projectionDelta = re(), this.projectionTransform = "none", this.scheduleRender());
              return;
            }
            this.projectionDelta || (this.projectionDelta = re(), this.projectionDeltaWithTransform = re());
            let h = this.projectionTransform;
            Oe(this.projectionDelta, this.layoutCorrected, d, this.latestValues), this.projectionTransform = oi(this.projectionDelta, this.treeScale), (this.projectionTransform !== h || this.treeScale.x !== f || this.treeScale.y !== p2) && (this.hasProjected = true, this.scheduleRender(), this.notifyListeners("projectionUpdate", d)), ie.recalculatedProjection++;
          }
          hide() {
            this.isVisible = false;
          }
          show() {
            this.isVisible = true;
          }
          scheduleRender(i2 = true) {
            if (this.options.scheduleRender && this.options.scheduleRender(), i2) {
              let a = this.getStack();
              a && a.scheduleRender();
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
          }
          setAnimationOrigin(i2, a = false) {
            let c = this.snapshot, l2 = c ? c.latestValues : {}, u2 = { ...this.latestValues }, m2 = re();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
            let f = k(), p2 = c ? c.source : void 0, d = this.layout ? this.layout.source : void 0, h = p2 !== d, y = this.getStack(), S = !y || y.members.length <= 1, x = !!(h && !S && this.options.crossfade === true && !this.path.some(mm));
            this.animationProgress = 0;
            let g;
            this.mixTargetDelta = (v) => {
              let P = v / 1e3;
              Na(m2.x, i2.x, P), Na(m2.y, i2.y, P), this.setTargetDelta(m2), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Fe(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), um(this.relativeTarget, this.relativeTargetOrigin, f, P), g && La(this.relativeTarget, g) && (this.isProjectionDirty = false), g || (g = k()), it(g, this.relativeTarget)), h && (this.animationValues = u2, Aa(u2, l2, this.latestValues, P, x, S)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = P;
            }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
          }
          startAnimation(i2) {
            this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (O(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = V.update(() => {
              Be.hasAnimatedSinceResize = true, this.currentAnimation = Ao(0, Fa, {
                ...i2, onUpdate: (a) => {
                  this.mixTargetDelta(a), i2.onUpdate && i2.onUpdate(a);
                }, onComplete: () => {
                  i2.onComplete && i2.onComplete(), this.completeAnimation();
                }
              }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
            });
          }
          completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
            let i2 = this.getStack();
            i2 && i2.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
          }
          finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Fa), this.currentAnimation.stop()), this.completeAnimation();
          }
          applyTransformsToTarget() {
            let i2 = this.getLead(), { targetWithTransforms: a, target: c, layout: l2, latestValues: u2 } = i2;
            if (!(!a || !c || !l2)) {
              if (this !== i2 && this.layout && l2 && Wa(this.options.animationType, this.layout.layoutBox, l2.layoutBox)) {
                c = this.target || k();
                let m2 = $(this.layout.layoutBox.x);
                c.x.min = i2.target.x.min, c.x.max = c.x.min + m2;
                let f = $(this.layout.layoutBox.y);
                c.y.min = i2.target.y.min, c.y.max = c.y.min + f;
              }
              it(a, c), ne(a, u2), Oe(this.projectionDeltaWithTransform, this.layoutCorrected, a, u2);
            }
          }
          registerSharedNode(i2, a) {
            this.sharedNodes.has(i2) || this.sharedNodes.set(i2, new kr()), this.sharedNodes.get(i2).add(a);
            let l2 = a.options.initialPromotionConfig;
            a.promote({ transition: l2 ? l2.transition : void 0, preserveFollowOpacity: l2 && l2.shouldPreserveFollowOpacity ? l2.shouldPreserveFollowOpacity(a) : void 0 });
          }
          isLead() {
            let i2 = this.getStack();
            return i2 ? i2.lead === this : true;
          }
          getLead() {
            var i2;
            let { layoutId: a } = this.options;
            return a ? ((i2 = this.getStack()) === null || i2 === void 0 ? void 0 : i2.lead) || this : this;
          }
          getPrevLead() {
            var i2;
            let { layoutId: a } = this.options;
            return a ? (i2 = this.getStack()) === null || i2 === void 0 ? void 0 : i2.prevLead : void 0;
          }
          getStack() {
            let { layoutId: i2 } = this.options;
            if (i2)
              return this.root.sharedNodes.get(i2);
          }
          promote({ needsReset: i2, transition: a, preserveFollowOpacity: c } = {}) {
            let l2 = this.getStack();
            l2 && l2.promote(this, c), i2 && (this.projectionDelta = void 0, this.needsReset = true), a && this.setOptions({ transition: a });
          }
          relegate() {
            let i2 = this.getStack();
            return i2 ? i2.relegate(this) : false;
          }
          resetRotation() {
            let { visualElement: i2 } = this.options;
            if (!i2)
              return;
            let a = false, { latestValues: c } = i2;
            if ((c.rotate || c.rotateX || c.rotateY || c.rotateZ) && (a = true), !a)
              return;
            let l2 = {};
            for (let u2 = 0; u2 < Oa.length; u2++) {
              let m2 = "rotate" + Oa[u2];
              c[m2] && (l2[m2] = c[m2], i2.setStaticValue(m2, 0));
            }
            i2.render();
            for (let u2 in l2)
              i2.setStaticValue(u2, l2[u2]);
            i2.scheduleRender();
          }
          getProjectionStyles(i2) {
            var a, c;
            if (!this.instance || this.isSVG)
              return;
            if (!this.isVisible)
              return Zu;
            let l2 = { visibility: "" }, u2 = this.getTransformTemplate();
            if (this.needsReset)
              return this.needsReset = false, l2.opacity = "", l2.pointerEvents = qt(i2?.pointerEvents) || "", l2.transform = u2 ? u2(this.latestValues, "") : "none", l2;
            let m2 = this.getLead();
            if (!this.projectionDelta || !this.layout || !m2.target) {
              let h = {};
              return this.options.layoutId && (h.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, h.pointerEvents = qt(i2?.pointerEvents) || ""), this.hasProjected && !wt(this.latestValues) && (h.transform = u2 ? u2({}, "") : "none", this.hasProjected = false), h;
            }
            let f = m2.animationValues || m2.latestValues;
            this.applyTransformsToTarget(), l2.transform = oi(this.projectionDeltaWithTransform, this.treeScale, f), u2 && (l2.transform = u2(f, l2.transform));
            let { x: p2, y: d } = this.projectionDelta;
            l2.transformOrigin = `${p2.origin * 100}% ${d.origin * 100}% 0`, m2.animationValues ? l2.opacity = m2 === this ? (c = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && c !== void 0 ? c : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : l2.opacity = m2 === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
            for (let h in pe) {
              if (f[h] === void 0)
                continue;
              let { correct: y, applyTo: S } = pe[h], x = l2.transform === "none" ? f[h] : y(f[h], m2);
              if (S) {
                let g = S.length;
                for (let v = 0; v < g; v++)
                  l2[S[v]] = x;
              } else
                l2[h] = x;
            }
            return this.options.layoutId && (l2.pointerEvents = m2 === this ? qt(i2?.pointerEvents) || "" : "none"), l2;
          }
          clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0;
          }
          resetTree() {
            this.root.nodes.forEach((i2) => {
              var a;
              return (a = i2.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
            }), this.root.nodes.forEach(Ba), this.root.sharedNodes.clear();
          }
        };
      }
      function Qu(t2) {
        t2.updateLayout();
      }
      function tm(t2) {
        var e;
        let o2 = ((e = t2.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t2.snapshot;
        if (t2.isLead() && t2.layout && o2 && t2.hasListeners("didUpdate")) {
          let { layoutBox: r, measuredBox: n2 } = t2.layout, { animationType: s2 } = t2.options, i2 = o2.source !== t2.layout.source;
          s2 === "size" ? ot((m2) => {
            let f = i2 ? o2.measuredBox[m2] : o2.layoutBox[m2], p2 = $(f);
            f.min = r[m2].min, f.max = f.min + p2;
          }) : Wa(s2, o2.layoutBox, r) && ot((m2) => {
            let f = i2 ? o2.measuredBox[m2] : o2.layoutBox[m2], p2 = $(r[m2]);
            f.max = f.min + p2, t2.relativeTarget && !t2.currentAnimation && (t2.isProjectionDirty = true, t2.relativeTarget[m2].max = t2.relativeTarget[m2].min + p2);
          });
          let a = re();
          Oe(a, r, o2.layoutBox);
          let c = re();
          i2 ? Oe(c, t2.applyTransform(n2, true), o2.measuredBox) : Oe(c, r, o2.layoutBox);
          let l2 = !Qn(a), u2 = false;
          if (!t2.resumeFrom) {
            let m2 = t2.getClosestProjectingParent();
            if (m2 && !m2.resumeFrom) {
              let { snapshot: f, layout: p2 } = m2;
              if (f && p2) {
                let d = k();
                Fe(d, o2.layoutBox, f.layoutBox);
                let h = k();
                Fe(h, r, p2.layoutBox), ti(d, h) || (u2 = true), m2.options.layoutRoot && (t2.relativeTarget = h, t2.relativeTargetOrigin = d, t2.relativeParent = m2);
              }
            }
          }
          t2.notifyListeners("didUpdate", { layout: r, snapshot: o2, delta: c, layoutDelta: a, hasLayoutChanged: l2, hasRelativeTargetChanged: u2 });
        } else if (t2.isLead()) {
          let { onExitComplete: r } = t2.options;
          r && r();
        }
        t2.options.transition = void 0;
      }
      function em(t2) {
        ie.totalNodes++, t2.parent && (t2.isProjecting() || (t2.isProjectionDirty = t2.parent.isProjectionDirty), t2.isSharedProjectionDirty || (t2.isSharedProjectionDirty = !!(t2.isProjectionDirty || t2.parent.isProjectionDirty || t2.parent.isSharedProjectionDirty)), t2.isTransformDirty || (t2.isTransformDirty = t2.parent.isTransformDirty));
      }
      function om(t2) {
        t2.isProjectionDirty = t2.isSharedProjectionDirty = t2.isTransformDirty = false;
      }
      function rm(t2) {
        t2.clearSnapshot();
      }
      function Ba(t2) {
        t2.clearMeasurements();
      }
      function nm(t2) {
        t2.isLayoutDirty = false;
      }
      function im(t2) {
        let { visualElement: e } = t2.options;
        e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t2.resetTransform();
      }
      function ja(t2) {
        t2.finishAnimation(), t2.targetDelta = t2.relativeTarget = t2.target = void 0, t2.isProjectionDirty = true;
      }
      function sm(t2) {
        t2.resolveTargetDelta();
      }
      function am(t2) {
        t2.calcProjection();
      }
      function cm(t2) {
        t2.resetRotation();
      }
      function lm(t2) {
        t2.removeLeadSnapshot();
      }
      function Na(t2, e, o2) {
        t2.translate = C(e.translate, 0, o2), t2.scale = C(e.scale, 1, o2), t2.origin = e.origin, t2.originPoint = e.originPoint;
      }
      function Ua(t2, e, o2, r) {
        t2.min = C(e.min, o2.min, r), t2.max = C(e.max, o2.max, r);
      }
      function um(t2, e, o2, r) {
        Ua(t2.x, e.x, o2.x, r), Ua(t2.y, e.y, o2.y, r);
      }
      function mm(t2) {
        return t2.animationValues && t2.animationValues.opacityExit !== void 0;
      }
      var fm = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
      var za = (t2) => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(t2);
      var Ga = za("applewebkit/") && !za("chrome/") ? Math.round : w;
      function Ha(t2) {
        t2.min = Ga(t2.min), t2.max = Ga(t2.max);
      }
      function pm(t2) {
        Ha(t2.x), Ha(t2.y);
      }
      function Wa(t2, e, o2) {
        return t2 === "position" || t2 === "preserve-aspect" && !br(ei(e), ei(o2), 0.2);
      }
      var $a = Or({ attachResizeListener: (t2, e) => Y(t2, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => true });
      var Mt = { current: void 0 };
      var Fr = Or({
        measureScroll: (t2) => ({ x: t2.scrollLeft, y: t2.scrollTop }), defaultParent: () => {
          if (!Mt.current) {
            let t2 = new $a({});
            t2.mount(window), t2.setOptions({ layoutScroll: true }), Mt.current = t2;
          }
          return Mt.current;
        }, resetTransform: (t2, e) => {
          t2.style.transform = e !== void 0 ? e : "none";
        }, checkIsScrollRoot: (t2) => window.getComputedStyle(t2).position === "fixed"
      });
      var Br = { pan: { Feature: Dr }, drag: { Feature: Rr, ProjectionNode: Fr, MeasureLayout: Lr } };
      var dm = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
      function hm(t2) {
        let e = dm.exec(t2);
        if (!e)
          return [,];
        let [, o2, r] = e;
        return [o2, r];
      }
      var gm = 4;
      function ni(t2, e, o2 = 1) {
        E(o2 <= gm, `Max CSS variable fallback depth detected in property "${t2}". This may indicate a circular fallback dependency.`);
        let [r, n2] = hm(t2);
        if (!r)
          return;
        let s2 = window.getComputedStyle(e).getPropertyValue(r);
        if (s2) {
          let i2 = s2.trim();
          return gr(i2) ? parseFloat(i2) : i2;
        } else
          return $o(n2) ? ni(n2, e, o2 + 1) : n2;
      }
      function Ka(t2, { ...e }, o2) {
        let r = t2.current;
        if (!(r instanceof Element))
          return { target: e, transitionEnd: o2 };
        o2 && (o2 = { ...o2 }), t2.values.forEach((n2) => {
          let s2 = n2.get();
          if (!$o(s2))
            return;
          let i2 = ni(s2, r);
          i2 && n2.set(i2);
        });
        for (let n2 in e) {
          let s2 = e[n2];
          if (!$o(s2))
            continue;
          let i2 = ni(s2, r);
          i2 && (e[n2] = i2, o2 || (o2 = {}), o2[n2] === void 0 && (o2[n2] = s2));
        }
        return { target: e, transitionEnd: o2 };
      }
      var ym = /* @__PURE__ */ new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]);
      var qa = (t2) => ym.has(t2);
      var xm = (t2) => Object.keys(t2).some(qa);
      var jr = (t2) => t2 === at || t2 === T;
      var _a = (t2, e) => parseFloat(t2.split(", ")[e]);
      var Ya = (t2, e) => (o2, { transform: r }) => {
        if (r === "none" || !r)
          return 0;
        let n2 = r.match(/^matrix3d\((.+)\)$/);
        if (n2)
          return _a(n2[1], e);
        {
          let s2 = r.match(/^matrix\((.+)\)$/);
          return s2 ? _a(s2[1], t2) : 0;
        }
      };
      var vm = /* @__PURE__ */ new Set(["x", "y", "z"]);
      var Sm = Ot.filter((t2) => !vm.has(t2));
      function Vm(t2) {
        let e = [];
        return Sm.forEach((o2) => {
          let r = t2.getValue(o2);
          r !== void 0 && (e.push([o2, r.get()]), r.set(o2.startsWith("scale") ? 1 : 0));
        }), e.length && t2.render(), e;
      }
      var Ne = { width: ({ x: t2 }, { paddingLeft: e = "0", paddingRight: o2 = "0" }) => t2.max - t2.min - parseFloat(e) - parseFloat(o2), height: ({ y: t2 }, { paddingTop: e = "0", paddingBottom: o2 = "0" }) => t2.max - t2.min - parseFloat(e) - parseFloat(o2), top: (t2, { top: e }) => parseFloat(e), left: (t2, { left: e }) => parseFloat(e), bottom: ({ y: t2 }, { top: e }) => parseFloat(e) + (t2.max - t2.min), right: ({ x: t2 }, { left: e }) => parseFloat(e) + (t2.max - t2.min), x: Ya(4, 13), y: Ya(5, 14) };
      Ne.translateX = Ne.x;
      Ne.translateY = Ne.y;
      var Tm = (t2, e, o2) => {
        let r = e.measureViewportBox(), n2 = e.current, s2 = getComputedStyle(n2), { display: i2 } = s2, a = {};
        i2 === "none" && e.setStaticValue("display", t2.display || "block"), o2.forEach((l2) => {
          a[l2] = Ne[l2](r, s2);
        }), e.render();
        let c = e.measureViewportBox();
        return o2.forEach((l2) => {
          let u2 = e.getValue(l2);
          u2 && u2.jump(a[l2]), t2[l2] = Ne[l2](c, s2);
        }), t2;
      };
      var bm = (t2, e, o2 = {}, r = {}) => {
        e = { ...e }, r = { ...r };
        let n2 = Object.keys(e).filter(qa), s2 = [], i2 = false, a = [];
        if (n2.forEach((c) => {
          let l2 = t2.getValue(c);
          if (!t2.hasValue(c))
            return;
          let u2 = o2[c], m2 = Le(u2), f = e[c], p2;
          if (Yt(f)) {
            let d = f.length, h = f[0] === null ? 1 : 0;
            u2 = f[h], m2 = Le(u2);
            for (let y = h; y < d && f[y] !== null; y++)
              p2 ? E(Le(f[y]) === p2, "All keyframes must be of the same type") : (p2 = Le(f[y]), E(p2 === m2 || jr(m2) && jr(p2), "Keyframes must be of the same dimension as the current value"));
          } else
            p2 = Le(f);
          if (m2 !== p2)
            if (jr(m2) && jr(p2)) {
              let d = l2.get();
              typeof d == "string" && l2.set(parseFloat(d)), typeof f == "string" ? e[c] = parseFloat(f) : Array.isArray(f) && p2 === T && (e[c] = f.map(parseFloat));
            } else
              m2?.transform && p2?.transform && (u2 === 0 || f === 0) ? u2 === 0 ? l2.set(p2.transform(u2)) : e[c] = m2.transform(f) : (i2 || (s2 = Vm(t2), i2 = true), a.push(c), r[c] = r[c] !== void 0 ? r[c] : e[c], l2.jump(f));
        }), a.length) {
          let c = a.indexOf("height") >= 0 ? window.pageYOffset : null, l2 = Tm(e, t2, a);
          return s2.length && s2.forEach(([u2, m2]) => {
            t2.getValue(u2).set(m2);
          }), t2.render(), St && c !== null && window.scrollTo({ top: c }), { target: l2, transitionEnd: r };
        } else
          return { target: e, transitionEnd: r };
      };
      function Xa(t2, e, o2, r) {
        return xm(e) ? bm(t2, e, o2, r) : { target: e, transitionEnd: r };
      }
      var Za = (t2, e, o2, r) => {
        let n2 = Ka(t2, e, r);
        return e = n2.target, r = n2.transitionEnd, Xa(t2, e, o2, r);
      };
      var se = { current: null };
      var Ue = { current: false };
      function Nr() {
        if (Ue.current = true, !!St)
          if (window.matchMedia) {
            let t2 = window.matchMedia("(prefers-reduced-motion)"), e = () => se.current = t2.matches;
            t2.addListener(e), e();
          } else
            se.current = false;
      }
      function Ja(t2, e, o2) {
        let { willChange: r } = e;
        for (let n2 in e) {
          let s2 = e[n2], i2 = o2[n2];
          if (A(s2))
            t2.addValue(n2, s2), te(r) && r.add(n2);
          else if (A(i2))
            t2.addValue(n2, W(s2, { owner: t2 })), te(r) && r.remove(n2);
          else if (i2 !== s2)
            if (t2.hasValue(n2)) {
              let a = t2.getValue(n2);
              !a.hasAnimated && a.set(s2);
            } else {
              let a = t2.getStaticValue(n2);
              t2.addValue(n2, W(a !== void 0 ? a : s2, { owner: t2 }));
            }
        }
        for (let n2 in o2)
          e[n2] === void 0 && t2.removeValue(n2);
        return e;
      }
      var Et = /* @__PURE__ */ new WeakMap();
      var tc = Object.keys(Kt);
      var Pm = tc.length;
      var Qa = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
      var Cm = Je.length;
      var ae = class {
        constructor({ parent: e, props: o2, presenceContext: r, reducedMotionConfig: n2, visualState: s2 }, i2 = {}) {
          this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = false, this.isControllingVariants = false, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
            this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
          }, this.scheduleRender = () => V.render(this.render, false, true);
          let { latestValues: a, renderState: c } = s2;
          this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = o2.initial ? { ...a } : {}, this.renderState = c, this.parent = e, this.props = o2, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = n2, this.options = i2, this.isControllingVariants = $t(o2), this.isVariantNode = zo(o2), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
          let { willChange: l2, ...u2 } = this.scrapeMotionValuesFromProps(o2, {});
          for (let m2 in u2) {
            let f = u2[m2];
            a[m2] !== void 0 && A(f) && (f.set(a[m2], false), te(l2) && l2.add(m2));
          }
        }
        scrapeMotionValuesFromProps(e, o2) {
          return {};
        }
        mount(e) {
          this.current = e, Et.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((o2, r) => this.bindToMotionValue(r, o2)), Ue.current || Nr(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : se.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
        }
        unmount() {
          Et.delete(this.current), this.projection && this.projection.unmount(), O(this.notifyUpdate), O(this.render), this.valueSubscriptions.forEach((e) => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
          for (let e in this.events)
            this.events[e].clear();
          for (let e in this.features)
            this.features[e].unmount();
          this.current = null;
        }
        bindToMotionValue(e, o2) {
          let r = z.has(e), n2 = o2.on("change", (i2) => {
            this.latestValues[e] = i2, this.props.onUpdate && V.update(this.notifyUpdate, false, true), r && this.projection && (this.projection.isTransformDirty = true);
          }), s2 = o2.on("renderRequest", this.scheduleRender);
          this.valueSubscriptions.set(e, () => {
            n2(), s2();
          });
        }
        sortNodePosition(e) {
          return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
        }
        loadFeatures({ children: e, ...o2 }, r, n2, s2) {
          let i2, a;
          for (let c = 0; c < Pm; c++) {
            let l2 = tc[c], { isEnabled: u2, Feature: m2, ProjectionNode: f, MeasureLayout: p2 } = Kt[l2];
            f && (i2 = f), u2(o2) && (!this.features[l2] && m2 && (this.features[l2] = new m2(this)), p2 && (a = p2));
          }
          if ((this.type === "html" || this.type === "svg") && !this.projection && i2) {
            this.projection = new i2(this.latestValues, this.parent && this.parent.projection);
            let { layoutId: c, layout: l2, drag: u2, dragConstraints: m2, layoutScroll: f, layoutRoot: p2 } = o2;
            this.projection.setOptions({ layoutId: c, layout: l2, alwaysMeasureLayout: !!u2 || m2 && Tt(m2), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: typeof l2 == "string" ? l2 : "both", initialPromotionConfig: s2, layoutScroll: f, layoutRoot: p2 });
          }
          return a;
        }
        updateFeatures() {
          for (let e in this.features) {
            let o2 = this.features[e];
            o2.isMounted ? o2.update() : (o2.mount(), o2.isMounted = true);
          }
        }
        triggerBuild() {
          this.build(this.renderState, this.latestValues, this.options, this.props);
        }
        measureViewportBox() {
          return this.current ? this.measureInstanceViewportBox(this.current, this.props) : k();
        }
        getStaticValue(e) {
          return this.latestValues[e];
        }
        setStaticValue(e, o2) {
          this.latestValues[e] = o2;
        }
        makeTargetAnimatable(e, o2 = true) {
          return this.makeTargetAnimatableFromInstance(e, this.props, o2);
        }
        update(e, o2) {
          (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = o2;
          for (let r = 0; r < Qa.length; r++) {
            let n2 = Qa[r];
            this.propEventSubscriptions[n2] && (this.propEventSubscriptions[n2](), delete this.propEventSubscriptions[n2]);
            let s2 = e["on" + n2];
            s2 && (this.propEventSubscriptions[n2] = this.on(n2, s2));
          }
          this.prevMotionValues = Ja(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
        }
        getProps() {
          return this.props;
        }
        getVariant(e) {
          return this.props.variants ? this.props.variants[e] : void 0;
        }
        getDefaultTransition() {
          return this.props.transition;
        }
        getTransformPagePoint() {
          return this.props.transformPagePoint;
        }
        getClosestVariantNode() {
          return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
        }
        getVariantContext(e = false) {
          if (e)
            return this.parent ? this.parent.getVariantContext() : void 0;
          if (!this.isControllingVariants) {
            let r = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (r.initial = this.props.initial), r;
          }
          let o2 = {};
          for (let r = 0; r < Cm; r++) {
            let n2 = Je[r], s2 = this.props[n2];
            (bt(s2) || s2 === false) && (o2[n2] = s2);
          }
          return o2;
        }
        addVariantChild(e) {
          let o2 = this.getClosestVariantNode();
          if (o2)
            return o2.variantChildren && o2.variantChildren.add(e), () => o2.variantChildren.delete(e);
        }
        addValue(e, o2) {
          o2 !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, o2)), this.values.set(e, o2), this.latestValues[e] = o2.get();
        }
        removeValue(e) {
          this.values.delete(e);
          let o2 = this.valueSubscriptions.get(e);
          o2 && (o2(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
        }
        hasValue(e) {
          return this.values.has(e);
        }
        getValue(e, o2) {
          if (this.props.values && this.props.values[e])
            return this.props.values[e];
          let r = this.values.get(e);
          return r === void 0 && o2 !== void 0 && (r = W(o2, { owner: this }), this.addValue(e, r)), r;
        }
        readValue(e) {
          var o2;
          return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (o2 = this.getBaseTargetFromProps(this.props, e)) !== null && o2 !== void 0 ? o2 : this.readValueFromInstance(this.current, e, this.options);
        }
        setBaseTarget(e, o2) {
          this.baseTarget[e] = o2;
        }
        getBaseTarget(e) {
          var o2;
          let { initial: r } = this.props, n2 = typeof r == "string" || typeof r == "object" ? (o2 = Ve(this.props, r)) === null || o2 === void 0 ? void 0 : o2[e] : void 0;
          if (r && n2 !== void 0)
            return n2;
          let s2 = this.getBaseTargetFromProps(this.props, e);
          return s2 !== void 0 && !A(s2) ? s2 : this.initialValues[e] !== void 0 && n2 === void 0 ? void 0 : this.baseTarget[e];
        }
        on(e, o2) {
          return this.events[e] || (this.events[e] = new zt()), this.events[e].add(o2);
        }
        notify(e, ...o2) {
          this.events[e] && this.events[e].notify(...o2);
        }
      };
      var ze = class extends ae {
        sortInstanceNodePosition(e, o2) {
          return e.compareDocumentPosition(o2) & 2 ? 1 : -1;
        }
        getBaseTargetFromProps(e, o2) {
          return e.style ? e.style[o2] : void 0;
        }
        removeValueFromRenderState(e, { vars: o2, style: r }) {
          delete o2[e], delete r[e];
        }
        makeTargetAnimatableFromInstance({ transition: e, transitionEnd: o2, ...r }, { transformValues: n2 }, s2) {
          let i2 = vr(r, e || {}, this);
          if (n2 && (o2 && (o2 = n2(o2)), r && (r = n2(r)), i2 && (i2 = n2(i2))), s2) {
            To(this, r, i2);
            let a = Za(this, r, i2, o2);
            o2 = a.transitionEnd, r = a.target;
          }
          return { transition: e, transitionEnd: o2, ...r };
        }
      };
      function Am(t2) {
        return window.getComputedStyle(t2);
      }
      var Ge = class extends ze {
        constructor() {
          super(...arguments), this.type = "html";
        }
        readValueFromInstance(e, o2) {
          if (z.has(o2)) {
            let r = we(o2);
            return r && r.default || 0;
          } else {
            let r = Am(e), n2 = (de(o2) ? r.getPropertyValue(o2) : r[o2]) || 0;
            return typeof n2 == "string" ? n2.trim() : n2;
          }
        }
        measureInstanceViewportBox(e, { transformPagePoint: o2 }) {
          return qn(e, o2);
        }
        build(e, o2, r, n2) {
          he(e, o2, r, n2.transformTemplate);
        }
        scrapeMotionValuesFromProps(e, o2) {
          return Se(e, o2);
        }
        handleChildMotionValue() {
          this.childSubscription && (this.childSubscription(), delete this.childSubscription);
          let { children: e } = this.props;
          A(e) && (this.childSubscription = e.on("change", (o2) => {
            this.current && (this.current.textContent = `${o2}`);
          }));
        }
        renderInstance(e, o2, r, n2) {
          Yo(e, o2, r, n2);
        }
      };
      var He = class extends ze {
        constructor() {
          super(...arguments), this.type = "svg", this.isSVGTag = false;
        }
        getBaseTargetFromProps(e, o2) {
          return e[o2];
        }
        readValueFromInstance(e, o2) {
          if (z.has(o2)) {
            let r = we(o2);
            return r && r.default || 0;
          }
          return o2 = qo.has(o2) ? o2 : Vt(o2), e.getAttribute(o2);
        }
        measureInstanceViewportBox() {
          return k();
        }
        scrapeMotionValuesFromProps(e, o2) {
          return Zo(e, o2);
        }
        build(e, o2, r, n2) {
          xe(e, o2, r, this.isSVGTag, n2.transformTemplate);
        }
        renderInstance(e, o2, r, n2) {
          Xo(e, o2, r, n2);
        }
        mount(e) {
          this.isSVGTag = ve(e.tagName), super.mount(e);
        }
      };
      var wo = (t2, e) => fe(t2) ? new He(e, { enableHardwareAcceleration: false }) : new Ge(e, { enableHardwareAcceleration: true });
      var Ur = { layout: { ProjectionNode: Fr, MeasureLayout: Lr } };
      var ec = { ...bo, ...nr, ...Br, ...Ur };
      var Mo = Ho((t2, e) => io(t2, e, ec, wo));
      var Mm = Ho(io);
      function zr() {
        let t2 = (0, import_react21.useRef)(false);
        return X(() => (t2.current = true, () => {
          t2.current = false;
        }), []), t2;
      }
      function ce() {
        let t2 = zr(), [e, o2] = (0, import_react20.useState)(0), r = (0, import_react20.useCallback)(() => {
          t2.current && o2(e + 1);
        }, [e]);
        return [(0, import_react20.useCallback)(() => V.postRender(r), [r]), e];
      }
      var ii = class extends We.Component {
        getSnapshotBeforeUpdate(e) {
          let o2 = this.props.childRef.current;
          if (o2 && e.isPresent && !this.props.isPresent) {
            let r = this.props.sizeRef.current;
            r.height = o2.offsetHeight || 0, r.width = o2.offsetWidth || 0, r.top = o2.offsetTop, r.left = o2.offsetLeft;
          }
          return null;
        }
        componentDidUpdate() {
        }
        render() {
          return this.props.children;
        }
      };
      function nc({ children: t2, isPresent: e }) {
        let o2 = (0, import_react23.useId)(), r = (0, import_react23.useRef)(null), n2 = (0, import_react23.useRef)({ width: 0, height: 0, top: 0, left: 0 });
        return (0, import_react23.useInsertionEffect)(() => {
          let { width: s2, height: i2, top: a, left: c } = n2.current;
          if (e || !r.current || !s2 || !i2)
            return;
          r.current.dataset.motionPopId = o2;
          let l2 = document.createElement("style");
          return document.head.appendChild(l2), l2.sheet && l2.sheet.insertRule(`
          [data-motion-pop-id="${o2}"] {
            position: absolute !important;
            width: ${s2}px !important;
            height: ${i2}px !important;
            top: ${a}px !important;
            left: ${c}px !important;
          }
        `), () => {
              document.head.removeChild(l2);
            };
        }, [e]), We.createElement(ii, { isPresent: e, childRef: r, sizeRef: n2 }, We.cloneElement(t2, { ref: r }));
      }
      var Gr = ({ children: t2, initial: e, isPresent: o2, onExitComplete: r, custom: n2, presenceAffectsLayout: s2, mode: i2 }) => {
        let a = L(Im), c = (0, import_react22.useId)(), l2 = (0, import_react22.useMemo)(() => ({
          id: c, initial: e, isPresent: o2, custom: n2, onExitComplete: (u2) => {
            a.set(u2, true);
            for (let m2 of a.values())
              if (!m2)
                return;
            r && r();
          }, register: (u2) => (a.set(u2, false), () => a.delete(u2))
        }), s2 ? void 0 : [o2]);
        return (0, import_react22.useMemo)(() => {
          a.forEach((u2, m2) => a.set(m2, false));
        }, [o2]), Eo.useEffect(() => {
          !o2 && !a.size && r && r();
        }, [o2]), i2 === "popLayout" && (t2 = Eo.createElement(nc, { isPresent: o2 }, t2)), Eo.createElement(ft.Provider, { value: l2 }, t2);
      };
      function Im() {
        return /* @__PURE__ */ new Map();
      }
      function Ro(t2) {
        return (0, import_react24.useEffect)(() => () => t2(), []);
      }
      var le = (t2) => t2.key || "";
      function Um(t2, e) {
        t2.forEach((o2) => {
          let r = le(o2);
          e.set(r, o2);
        });
      }
      function zm(t2) {
        let e = [];
        return import_react19.Children.forEach(t2, (o2) => {
          (0, import_react19.isValidElement)(o2) && e.push(o2);
        }), e;
      }
      var Gm = ({ children: t2, custom: e, initial: o2 = true, onExitComplete: r, exitBeforeEnter: n2, presenceAffectsLayout: s2 = true, mode: i2 = "sync" }) => {
        E(!n2, "Replace exitBeforeEnter with mode='wait'");
        let a = (0, import_react19.useContext)(pt).forceRender || ce()[0], c = zr(), l2 = zm(t2), u2 = l2, m2 = (0, import_react19.useRef)(/* @__PURE__ */ new Map()).current, f = (0, import_react19.useRef)(u2), p2 = (0, import_react19.useRef)(/* @__PURE__ */ new Map()).current, d = (0, import_react19.useRef)(true);
        if (X(() => {
          d.current = false, Um(l2, p2), f.current = u2;
        }), Ro(() => {
          d.current = true, p2.clear(), m2.clear();
        }), d.current)
          return Rt.createElement(Rt.Fragment, null, u2.map((x) => Rt.createElement(Gr, { key: le(x), isPresent: true, initial: o2 ? void 0 : false, presenceAffectsLayout: s2, mode: i2 }, x)));
        u2 = [...u2];
        let h = f.current.map(le), y = l2.map(le), S = h.length;
        for (let x = 0; x < S; x++) {
          let g = h[x];
          y.indexOf(g) === -1 && !m2.has(g) && m2.set(g, void 0);
        }
        return i2 === "wait" && m2.size && (u2 = []), m2.forEach((x, g) => {
          if (y.indexOf(g) !== -1)
            return;
          let v = p2.get(g);
          if (!v)
            return;
          let P = h.indexOf(g), R = x;
          if (!R) {
            let D = () => {
              m2.delete(g);
              let b = Array.from(p2.keys()).filter((M) => !y.includes(M));
              if (b.forEach((M) => p2.delete(M)), f.current = l2.filter((M) => {
                let U = le(M);
                return U === g || b.includes(U);
              }), !m2.size) {
                if (c.current === false)
                  return;
                a(), r && r();
              }
            };
            R = Rt.createElement(Gr, { key: le(v), isPresent: false, onExitComplete: D, custom: e, presenceAffectsLayout: s2, mode: i2 }, v), m2.set(g, R);
          }
          u2.splice(P, 0, R);
        }), u2 = u2.map((x) => {
          let g = x.key;
          return m2.has(g) ? x : Rt.createElement(Gr, { key: le(x), isPresent: true, presenceAffectsLayout: s2, mode: i2 }, x);
        }), Rt.createElement(Rt.Fragment, null, m2.size ? u2 : u2.map((x) => (0, import_react19.cloneElement)(x)));
      };
      var ai = (0, import_react28.createContext)(null);
      var Wr = (0, import_react30.createContext)(null);
      function mc(t2, e, o2, r) {
        if (!r)
          return t2;
        let n2 = t2.findIndex((u2) => u2.value === e);
        if (n2 === -1)
          return t2;
        let s2 = r > 0 ? 1 : -1, i2 = t2[n2 + s2];
        if (!i2)
          return t2;
        let a = t2[n2], c = i2.layout, l2 = C(c.min, c.max, 0.5);
        return s2 === 1 && a.layout.max + o2 > l2 || s2 === -1 && a.layout.min + o2 < l2 ? Ns(t2, n2, n2 + s2) : t2;
      }
      function sf({ children: t2, as: e = "ul", axis: o2 = "y", onReorder: r, values: n2, ...s2 }, i2) {
        let a = L(() => Mo(e)), c = [], l2 = (0, import_react29.useRef)(false);
        E(!!n2, "Reorder.Group must be provided a values prop");
        let u2 = {
          axis: o2, registerItem: (m2, f) => {
            let p2 = c.findIndex((d) => m2 === d.value);
            p2 !== -1 ? c[p2].layout = f[o2] : c.push({ value: m2, layout: f[o2] }), c.sort(cf);
          }, updateOrder: (m2, f, p2) => {
            if (l2.current)
              return;
            let d = mc(c, m2, f, p2);
            c !== d && (l2.current = true, r(d.map(af).filter((h) => n2.indexOf(h) !== -1)));
          }
        };
        return (0, import_react29.useEffect)(() => {
          l2.current = false;
        }), ui.createElement(a, { ...s2, ref: i2, ignoreStrict: true }, ui.createElement(Wr.Provider, { value: u2 }, t2));
      }
      var fc = (0, import_react29.forwardRef)(sf);
      function af(t2) {
        return t2.value;
      }
      function cf(t2, e) {
        return t2.layout.min - e.layout.min;
      }
      function rt(t2) {
        let e = L(() => W(t2)), { isStatic: o2 } = (0, import_react32.useContext)(K);
        if (o2) {
          let [, r] = (0, import_react32.useState)(t2);
          (0, import_react32.useEffect)(() => e.on("change", r), []);
        }
        return e;
      }
      var ff = (t2) => t2 && typeof t2 == "object" && t2.mix;
      var pf = (t2) => ff(t2) ? t2.mix : void 0;
      function mi(...t2) {
        let e = !Array.isArray(t2[0]), o2 = e ? 0 : -1, r = t2[0 + o2], n2 = t2[1 + o2], s2 = t2[2 + o2], i2 = t2[3 + o2], a = At(n2, s2, { mixer: pf(s2[0]), ...i2 });
        return e ? a(r) : a;
      }
      function $e(t2, e) {
        let o2 = rt(e()), r = () => o2.set(e());
        return r(), X(() => {
          let n2 = () => V.update(r, false, true), s2 = t2.map((i2) => i2.on("change", n2));
          return () => {
            s2.forEach((i2) => i2()), O(r);
          };
        }), o2;
      }
      function pc(t2) {
        Re.current = [], t2();
        let e = $e(Re.current, t2);
        return Re.current = void 0, e;
      }
      function Ke(t2, e, o2, r) {
        if (typeof t2 == "function")
          return pc(t2);
        let n2 = typeof e == "function" ? e : mi(e, o2, r);
        return Array.isArray(t2) ? dc(t2, n2) : dc([t2], ([s2]) => n2(s2));
      }
      function dc(t2, e) {
        let o2 = L(() => []);
        return $e(t2, () => {
          o2.length = 0;
          let r = t2.length;
          for (let n2 = 0; n2 < r; n2++)
            o2[n2] = t2[n2].get();
          return e(o2);
        });
      }
      function hc(t2, e = 0) {
        return A(t2) ? t2 : rt(e);
      }
      function gf({ children: t2, style: e = {}, value: o2, as: r = "li", onDrag: n2, layout: s2 = true, ...i2 }, a) {
        let c = L(() => Mo(r)), l2 = (0, import_react31.useContext)(Wr), u2 = { x: hc(e.x), y: hc(e.y) }, m2 = Ke([u2.x, u2.y], ([h, y]) => h || y ? 1 : "unset");
        E(!!l2, "Reorder.Item must be a child of Reorder.Group");
        let { axis: f, registerItem: p2, updateOrder: d } = l2;
        return gc.createElement(c, {
          drag: f, ...i2, dragSnapToOrigin: true, style: { ...e, x: u2.x, y: u2.y, zIndex: m2 }, layout: s2, onDrag: (h, y) => {
            let { velocity: S } = y;
            S[f] && d(o2, u2[f].get(), S[f]), n2 && n2(h, y);
          }, onLayoutMeasure: (h) => p2(o2, h), ref: a, ignoreStrict: true
        }, t2);
      }
      var yc = (0, import_react31.forwardRef)(gf);
      var fi = { renderer: wo, ...bo, ...nr };
      var xf = { ...fi, ...Br, ...Ur };
      function Gt(t2, e, o2) {
        var r;
        if (typeof t2 == "string") {
          let n2 = document;
          e && (E(!!e.current, "Scope provided, but no element detected."), n2 = e.current), o2 ? ((r = o2[t2]) !== null && r !== void 0 || (o2[t2] = n2.querySelectorAll(t2)), t2 = o2[t2]) : t2 = n2.querySelectorAll(t2);
        } else
          t2 instanceof Element && (t2 = [t2]);
        return Array.from(t2 || []);
      }
      function Yr(t2, e) {
        let o2, r = () => {
          let { currentTime: n2 } = e, i2 = (n2 === null ? 0 : n2.value) / 100;
          o2 !== i2 && t2(i2), o2 = i2;
        };
        return V.update(r, true), () => O(r);
      }
      var qr = fr(() => window.ScrollTimeline !== void 0);
      var Oo = class {
        constructor(e) {
          this.animations = e.filter(Boolean);
        }
        then(e, o2) {
          return Promise.all(this.animations).then(e).catch(o2);
        }
        getAll(e) {
          return this.animations[0][e];
        }
        setAll(e, o2) {
          for (let r = 0; r < this.animations.length; r++)
            this.animations[r][e] = o2;
        }
        attachTimeline(e) {
          let o2 = this.animations.map((r) => {
            if (qr() && r.attachTimeline)
              r.attachTimeline(e);
            else
              return r.pause(), Yr((n2) => {
                r.time = r.duration * n2;
              }, e);
          });
          return () => {
            o2.forEach((r, n2) => {
              r && r(), this.animations[n2].stop();
            });
          };
        }
        get time() {
          return this.getAll("time");
        }
        set time(e) {
          this.setAll("time", e);
        }
        get speed() {
          return this.getAll("speed");
        }
        set speed(e) {
          this.setAll("speed", e);
        }
        get duration() {
          let e = 0;
          for (let o2 = 0; o2 < this.animations.length; o2++)
            e = Math.max(e, this.animations[o2].duration);
          return e;
        }
        runAll(e) {
          this.animations.forEach((o2) => o2[e]());
        }
        play() {
          this.runAll("play");
        }
        pause() {
          this.runAll("pause");
        }
        stop() {
          this.runAll("stop");
        }
        cancel() {
          this.runAll("cancel");
        }
        complete() {
          this.runAll("complete");
        }
      };
      function kc(t2) {
        return typeof t2 == "object" && !Array.isArray(t2);
      }
      function Ic(t2) {
        let e = { presenceContext: null, props: {}, visualState: { renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {} }, latestValues: {} } }, o2 = Ir(t2) ? new He(e, { enableHardwareAcceleration: false }) : new Ge(e, { enableHardwareAcceleration: true });
        o2.mount(t2), Et.set(t2, o2);
      }
      function Oc(t2, e = 100) {
        let o2 = Qt({ keyframes: [0, e], ...t2 }), r = Math.min(vo(o2), 2e4);
        return { type: "keyframes", ease: (n2) => o2.next(r * n2).value / e, duration: H(r) };
      }
      function Si(t2, e, o2, r) {
        var n2;
        return typeof e == "number" ? e : e.startsWith("-") || e.startsWith("+") ? Math.max(0, t2 + parseFloat(e)) : e === "<" ? o2 : (n2 = r.get(e)) !== null && n2 !== void 0 ? n2 : t2;
      }
      var Fo = (t2, e, o2) => {
        let r = e - t2;
        return ((o2 - t2) % r + r) % r + t2;
      };
      function Fc(t2, e) {
        return ir(t2) ? t2[Fo(0, t2.length, e)] : t2;
      }
      function Zf(t2, e, o2) {
        for (let r = 0; r < t2.length; r++) {
          let n2 = t2[r];
          n2.at > e && n2.at < o2 && (mt(t2, n2), r--);
        }
      }
      function Bc(t2, e, o2, r, n2, s2) {
        Zf(t2, n2, s2);
        for (let i2 = 0; i2 < e.length; i2++)
          t2.push({ value: e[i2], at: C(n2, s2, r[i2]), easing: Fc(o2, i2) });
      }
      function jc(t2, e) {
        return t2.at === e.at ? t2.value === null ? 1 : e.value === null ? -1 : 0 : t2.at - e.at;
      }
      var Jf = "easeInOut";
      function zc(t2, { defaultTransition: e = {}, ...o2 } = {}, r) {
        let n2 = e.duration || 0.3, s2 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Map(), a = {}, c = /* @__PURE__ */ new Map(), l2 = 0, u2 = 0, m2 = 0;
        for (let f = 0; f < t2.length; f++) {
          let p2 = t2[f];
          if (typeof p2 == "string") {
            c.set(p2, u2);
            continue;
          } else if (!Array.isArray(p2)) {
            c.set(p2.name, Si(u2, p2.at, l2, c));
            continue;
          }
          let [d, h, y = {}] = p2;
          y.at !== void 0 && (u2 = Si(u2, y.at, l2, c));
          let S = 0, x = (g, v, P, R = 0, D = 0) => {
            let b = Qf(g), { delay: M = 0, times: U = Ce(b), type: Dt = "keyframes", ...nt } = v, { ease: st = e.ease || "easeOut", duration: B } = v, xt = typeof M == "function" ? M(R, D) : M, N = b.length;
            if (N <= 2 && Dt === "spring") {
              let qe = 100;
              if (N === 2 && op(b)) {
                let Bo = b[1] - b[0];
                qe = Math.abs(Bo);
              }
              let I = { ...nt };
              B !== void 0 && (I.duration = tt(B));
              let kt = Oc(I, qe);
              st = kt.ease, B = kt.duration;
            }
            B ?? (B = n2);
            let ct = u2 + xt, Lt = ct + B;
            U.length === 1 && U[0] === 0 && (U[1] = 1);
            let vt = U.length - b.length;
            vt > 0 && lr(U, vt), b.length === 1 && b.unshift(null), Bc(P, b, st, U, ct, Lt), S = Math.max(xt + B, S), m2 = Math.max(Lt, m2);
          };
          if (A(d)) {
            let g = Nc(d, i2);
            x(h, y, Uc("default", g));
          } else {
            let g = Gt(d, r, a), v = g.length;
            for (let P = 0; P < v; P++) {
              h = h, y = y;
              let R = g[P], D = Nc(R, i2);
              for (let b in h)
                x(h[b], tp(y, b), Uc(b, D), P, v);
            }
          }
          l2 = u2, u2 += S;
        }
        return i2.forEach((f, p2) => {
          for (let d in f) {
            let h = f[d];
            h.sort(jc);
            let y = [], S = [], x = [];
            for (let v = 0; v < h.length; v++) {
              let { at: P, value: R, easing: D } = h[v];
              y.push(R), S.push(et(0, m2, P)), x.push(D || "easeOut");
            }
            S[0] !== 0 && (S.unshift(0), y.unshift(y[0]), x.unshift(Jf)), S[S.length - 1] !== 1 && (S.push(1), y.push(null)), s2.has(p2) || s2.set(p2, { keyframes: {}, transition: {} });
            let g = s2.get(p2);
            g.keyframes[d] = y, g.transition[d] = { ...e, duration: m2, ease: x, times: S, ...o2 };
          }
        }), s2;
      }
      function Nc(t2, e) {
        return !e.has(t2) && e.set(t2, {}), e.get(t2);
      }
      function Uc(t2, e) {
        return e[t2] || (e[t2] = []), e[t2];
      }
      function Qf(t2) {
        return Array.isArray(t2) ? t2 : [t2];
      }
      function tp(t2, e) {
        return t2[e] ? { ...t2, ...t2[e] } : { ...t2 };
      }
      var ep = (t2) => typeof t2 == "number";
      var op = (t2) => t2.every(ep);
      function Gc(t2, e, o2, r) {
        let n2 = Gt(t2, r), s2 = n2.length;
        E(!!s2, "No valid element provided.");
        let i2 = [];
        for (let a = 0; a < s2; a++) {
          let c = n2[a];
          Et.has(c) || Ic(c);
          let l2 = Et.get(c), u2 = { ...o2 };
          typeof u2.delay == "function" && (u2.delay = u2.delay(a, s2)), i2.push(...ke(l2, { ...e, transition: u2 }, {}));
        }
        return new Oo(i2);
      }
      var rp = (t2) => Array.isArray(t2) && Array.isArray(t2[0]);
      function np(t2, e, o2) {
        let r = [];
        return zc(t2, e, o2).forEach(({ keyframes: s2, transition: i2 }, a) => {
          let c;
          A(a) ? c = Ao(a, s2.default, i2.default) : c = Gc(a, s2, i2), r.push(c);
        }), new Oo(r);
      }
      var Xr = (t2) => {
        function e(o2, r, n2) {
          let s2;
          return rp(o2) ? s2 = np(o2, r, t2) : kc(r) ? s2 = Gc(o2, r, n2, t2) : s2 = Ao(o2, r, n2), t2 && t2.animations.push(s2), s2;
        }
        return e;
      };
      var ip = Xr();
      var Ci = () => ({});
      var Ep = Xt({ scrapeMotionValuesFromProps: Ci, createRenderState: Ci });
      var Gp = Te.reduce((t2, e) => (t2[e] = (o2) => O(o2), t2), {});

      // http-url:https://bytepack.bytedance.net/react-icons@^4.11.0/fa?bundle&externals=react,react-dom&noVersion=true
      init_define_import_meta();

      // http-url:https://bytepack.bytedance.net/v44/react-icons@4.12.0/es2021/fa.bundle.react.react-dom.external.js?noVersion=true
      init_define_import_meta();
      var import_react45 = __toESM(require_react());
      var import_react46 = __toESM(require_react());
      var i = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 };
      var n = import_react46.default.createContext && import_react46.default.createContext(i);
      var l = function () {
        return l = Object.assign || function (c) {
          for (var r, a = 1, h = arguments.length; a < h; a++) {
            r = arguments[a];
            for (var v in r)
              Object.prototype.hasOwnProperty.call(r, v) && (c[v] = r[v]);
          }
          return c;
        }, l.apply(this, arguments);
      };
      var p = function (c, r) {
        var a = {};
        for (var h in c)
          Object.prototype.hasOwnProperty.call(c, h) && r.indexOf(h) < 0 && (a[h] = c[h]);
        if (c != null && typeof Object.getOwnPropertySymbols == "function")
          for (var v = 0, h = Object.getOwnPropertySymbols(c); v < h.length; v++)
            r.indexOf(h[v]) < 0 && Object.prototype.propertyIsEnumerable.call(c, h[v]) && (a[h[v]] = c[h[v]]);
        return a;
      };
      function u(c) {
        return c && c.map(function (r, a) {
          return import_react45.default.createElement(r.tag, l({ key: a }, r.attr), u(r.child));
        });
      }
      function t(c) {
        return function (r) {
          return import_react45.default.createElement(m, l({ attr: l({}, c.attr) }, r), u(c.child));
        };
      }
      function m(c) {
        var r = function (a) {
          var h = c.attr, v = c.size, z2 = c.title, d = p(c, ["attr", "size", "title"]), g = v || a.size || "1em", e;
          return a.className && (e = a.className), c.className && (e = (e ? e + " " : "") + c.className), import_react45.default.createElement("svg", l({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, a.attr, h, d, { className: e, style: l(l({ color: c.color || a.color }, a.style), c.style), height: g, width: g, xmlns: "http://www.w3.org/2000/svg" }), z2 && import_react45.default.createElement("title", null, z2), c.children);
        };
        return n !== void 0 ? import_react45.default.createElement(n.Consumer, null, function (a) {
          return r(a);
        }) : r(i);
      }
      function y9(c) {
        return t({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M440.5 88.5l-52 52L415 167c9.4 9.4 9.4 24.6 0 33.9l-17.4 17.4c11.8 26.1 18.4 55.1 18.4 85.6 0 114.9-93.1 208-208 208S0 418.9 0 304 93.1 96 208 96c30.5 0 59.5 6.6 85.6 18.4L311 97c9.4-9.4 24.6-9.4 33.9 0l26.5 26.5 52-52 17.1 17zM500 60h-24c-6.6 0-12 5.4-12 12s5.4 12 12 12h24c6.6 0 12-5.4 12-12s-5.4-12-12-12zM440 0c-6.6 0-12 5.4-12 12v24c0 6.6 5.4 12 12 12s12-5.4 12-12V12c0-6.6-5.4-12-12-12zm33.9 55l17-17c4.7-4.7 4.7-12.3 0-17-4.7-4.7-12.3-4.7-17 0l-17 17c-4.7 4.7-4.7 12.3 0 17 4.8 4.7 12.4 4.7 17 0zm-67.8 0c4.7 4.7 12.3 4.7 17 0 4.7-4.7 4.7-12.3 0-17l-17-17c-4.7-4.7-12.3-4.7-17 0-4.7 4.7-4.7 12.3 0 17l17 17zm67.8 34c-4.7-4.7-12.3-4.7-17 0-4.7 4.7-4.7 12.3 0 17l17 17c4.7 4.7 12.3 4.7 17 0 4.7-4.7 4.7-12.3 0-17l-17-17zM112 272c0-35.3 28.7-64 64-64 8.8 0 16-7.2 16-16s-7.2-16-16-16c-52.9 0-96 43.1-96 96 0 8.8 7.2 16 16 16s16-7.2 16-16z" } }] })(c);
      }

      // index
      var NumberBomb = ({ onRestart }) => {
        const [bomb] = (0, import_react47.useState)(() => Math.floor(Math.random() * 100) + 1);
        const [minRange, setMinRange] = (0, import_react47.useState)(1);
        const [maxRange, setMaxRange] = (0, import_react47.useState)(100);
        const [showBomb, setShowBomb] = (0, import_react47.useState)(true);
        const [gameOver, setGameOver] = (0, import_react47.useState)(false);
        const bombIconVariants = {
          initial: { scale: 1, rotate: 0 },
          hover: {
            scale: 1.2,
            rotate: [0, -10, 10, -10, 0],
            transition: {
              rotate: {
                repeat: Infinity,
                duration: 1
              }
            }
          },
          explode: {
            scale: [1, 4, 0],
            opacity: [1, 1, 0],
            rotate: [0, 360, 720],
            transition: {
              duration: 0.8,
              ease: "easeOut"
            }
          }
        };
        const [isExploding, setIsExploding] = (0, import_react47.useState)(false);
        (0, import_react47.useEffect)(() => {
          if (gameOver) {
            setIsExploding(true);
          }
        }, [gameOver]);
        const isInRange = (num) => {
          return num >= minRange && num <= maxRange;
        };
        const handleNumberClick = (num) => {
          if (num === bomb) {
            setGameOver(true);
            return;
          }
          if (!isInRange(num)) {
            setShowBomb(false);
            setTimeout(() => setShowBomb(true), 1e3);
            return;
          }
          if (num < bomb) {
            setMinRange(num + 1);
          } else {
            setMaxRange(num - 1);
          }
        };
        return /* @__PURE__ */ import_react47.default.createElement("div", { className: "w-full max-w-4xl mx-auto p-4" }, /* @__PURE__ */ import_react47.default.createElement("div", { className: "bg-gradient-to-br from-blue-50 to-blue-100 rounded-xl p-6 shadow-lg" }, /* @__PURE__ */ import_react47.default.createElement("div", { className: "text-[20px] font-bold text-gray-700" }, "\u521D\u604B\u7CD6\u5927\u5C0F\u59D0\u7684\u6570\u5B57\u70B8\u5F39"), /* @__PURE__ */ import_react47.default.createElement("div", { className: "flex justify-between items-center mb-6" }, /* @__PURE__ */ import_react47.default.createElement("div", { className: "text-xl font-bold text-gray-700" }, "\u8303\u56F4: ", minRange, " - ", maxRange), /* @__PURE__ */ import_react47.default.createElement(Gm, null, showBomb && !isExploding && /* @__PURE__ */ import_react47.default.createElement(
          Mo.div,
          {
            variants: bombIconVariants,
            initial: "initial",
            whileHover: "hover",
            className: "text-red-500 text-2xl cursor-pointer"
          },
    /* @__PURE__ */ import_react47.default.createElement(y9, null)
        ), isExploding && /* @__PURE__ */ import_react47.default.createElement(
          Mo.div,
          {
            className: "text-red-500 text-2xl",
            variants: bombIconVariants,
            initial: "initial",
            animate: "explode",
            onAnimationComplete: () => setIsExploding(false)
          },
    /* @__PURE__ */ import_react47.default.createElement("div", { className: "relative" }, /* @__PURE__ */ import_react47.default.createElement(y9, null), /* @__PURE__ */ import_react47.default.createElement(
            Mo.div,
            {
              className: "absolute inset-0 bg-yellow-400 rounded-full mix-blend-screen",
              initial: { scale: 0, opacity: 0 },
              animate: {
                scale: [1, 6]
              },
              transition: {
                duration: 0.8,
                ease: "easeOut"
              }
            }
          ), /* @__PURE__ */ import_react47.default.createElement(
            Mo.div,
            {
              className: "absolute inset-0 bg-red-500 rounded-full mix-blend-screen",
              initial: { scale: 0, opacity: 0 },
              animate: {
                scale: [1, 5]
              },
              transition: {
                duration: 0.6,
                delay: 0.1,
                ease: "easeOut"
              }
            }
          ))
        ))), /* @__PURE__ */ import_react47.default.createElement("div", { className: "grid grid-cols-10 gap-4" }, Array.from({ length: 100 }, (_2, i2) => i2 + 1).map((num) => /* @__PURE__ */ import_react47.default.createElement(
          Mo.button,
          {
            key: num,
            onClick: () => handleNumberClick(num),
            disabled: gameOver,
            whileHover: { scale: 1.05 },
            whileTap: { scale: 0.95 },
            className: `
                aspect-square relative flex items-center justify-center transition-colors
                ${!isInRange(num) ? "opacity-50 cursor-not-allowed" : num === bomb && gameOver ? "text-red-500" : "text-gray-700 hover:text-red-500"}
              `
          },
    /* @__PURE__ */ import_react47.default.createElement("div", { className: "relative w-full h-full" }, /* @__PURE__ */ import_react47.default.createElement(y9, { className: "w-full h-full p-1" }), /* @__PURE__ */ import_react47.default.createElement("div", {
            style: {
              left: "-5.5px",
              top: "7px"
            }, className: "absolute inset-0 flex items-center justify-center text-white font-bold text-lg"
          }, num))
        ))), gameOver && /* @__PURE__ */ import_react47.default.createElement(
          Mo.div,
          {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            className: "mt-6 text-center"
          },
    /* @__PURE__ */ import_react47.default.createElement("div", { className: "text-2xl font-bold text-red-500 mb-4 flex items-center justify-center gap-2" }, /* @__PURE__ */ import_react47.default.createElement("span", null, "\u{1F4A5}"), "\u6E38\u620F\u7ED3\u675F\uFF01\u70B8\u5F39\u6570\u5B57\u662F ", bomb, /* @__PURE__ */ import_react47.default.createElement("span", null, "\u{1F4A5}")),
    /* @__PURE__ */ import_react47.default.createElement(
            "button",
            {
              onClick: onRestart,
              className: "px-6 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 transition-all transform hover:scale-105 shadow-lg"
            },
            "\u91CD\u65B0\u5F00\u59CB"
          )
        )));
      };
      var index_default = NumberBomb;

      // App
      var App = () => {
        const [key, setKey] = (0, import_react48.useState)(0);
        const handleRestart = () => {
          setKey((prev) => prev + 1);
        };
        return /* @__PURE__ */ import_react48.default.createElement("div", { className: "min-h-screen bg-gray-100 py-8" }, /* @__PURE__ */ import_react48.default.createElement(index_default, { key, onRestart: handleRestart }));
      };
      var App_default = App;

      // aipa-entry.tsx
      var root = (0, import_client.createRoot)(document.getElementById("root"));
      root.render(
  /* @__PURE__ */ import_react49.default.createElement(import_react49.default.StrictMode, null, /* @__PURE__ */ import_react49.default.createElement(App_default, null))
      );

    })()
  </script>
</body>

</html>
